<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Androids on pkiller&#39;s Blog</title>
    <link>https://pkiller.com/android/</link>
    <description>Recent content in Androids on pkiller&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 13 May 2018 21:07:36 +0800</lastBuildDate>
    <atom:link href="https://pkiller.com/android/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>kernel逆向分析准备工作</title>
      <link>https://pkiller.com/android/kernel%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</link>
      <pubDate>Sun, 13 May 2018 21:07:36 +0800</pubDate>
      
      <guid>https://pkiller.com/android/kernel%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</guid>
      <description>

&lt;h1 id=&#34;步骤1-提取内核文件:74e08c5c20c35fafeb119b7ae5ebabe7&#34;&gt;步骤1、提取内核文件&lt;/h1&gt;

&lt;p&gt;提取内核有两种方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过固件包提取，通常包含在&lt;code&gt;KERNEL.img&lt;/code&gt;或&lt;code&gt;boot.img&lt;/code&gt;之中。&lt;/li&gt;
&lt;li&gt;通过root权限的手机提取。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;a-通过root权限设备提取:74e08c5c20c35fafeb119b7ae5ebabe7&#34;&gt;A. 通过root权限设备提取&lt;/h2&gt;

&lt;p&gt;以Nexus 5为例子&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 得到boot分区路径&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;adb shell
su
cd /dev/block/platform/msm_sdcc.1/by-name
ls -l boot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;1.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;boot 是个系统符号软链接，/dev/block/mmcblk0p19 就是boot分区.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 拷贝boot分区数据到sdcard&lt;/strong&gt;
用 dd 将其dump到sdcard文件夹下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dd if=/dev/block/mmcblk0p19 of=/sdcard/boot.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到boot.img文件!&lt;/p&gt;

&lt;h2 id=&#34;b-通过固件包提取:74e08c5c20c35fafeb119b7ae5ebabe7&#34;&gt;B. 通过固件包提取&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1. 解开固件包&lt;/strong&gt;
具体打包方法各厂商都不同，有些厂商还有加密。（如：OPPO)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 得到boot.img&lt;/strong&gt;
解包后可直接得到boot.img。大部分手机的固件都为&lt;code&gt;boot.img&lt;/code&gt;，少数会有其他名称(如华为EMUI: &lt;code&gt;KERNEL.img&lt;/code&gt;)&lt;/p&gt;

&lt;h2 id=&#34;x-从-boot-img-kernel-img-中提取kernel:74e08c5c20c35fafeb119b7ae5ebabe7&#34;&gt;X. 从&lt;code&gt;boot.img&lt;/code&gt; / &lt;code&gt;KERNEL.img&lt;/code&gt;中提取kernel&lt;/h2&gt;

&lt;p&gt;可以借助工具，工具有：
《binwalk》《mkboot》《unpackbootimg》&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;binwalk -e boot.img
mkboot KERNEL.img ./output/   # 实际测试有些问题，提取出的kernel.gz不完整
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可直接根据特征提有，粗略特征为：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 定位boot.img / KERNEL.img 中KERNEL的部分：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;搜索字符串&lt;code&gt;ANDROID!&lt;/code&gt;先定位到头部，头部后紧跟kernel的描述信息：
&lt;img src=&#34;2.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 提出kernel.gz包文件：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接着以此为起点寻找&amp;rdquo;1F 8B 08 00&amp;rdquo;，即gzip的头部Magic。长度不管（直接从此处到文件尾)保存到新的文件如：kernel.gz。
&lt;img src=&#34;3.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 解压出kernel.gz中的真正raw文件：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;然后用gzip命令解压出文件(用图形界面解压会报错)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gzip -d kernel.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;步骤2-用ida加载:74e08c5c20c35fafeb119b7ae5ebabe7&#34;&gt;步骤2、用IDA加载&lt;/h1&gt;

&lt;h2 id=&#34;arm64的内核:74e08c5c20c35fafeb119b7ae5ebabe7&#34;&gt;ARM64的内核&lt;/h2&gt;

&lt;p&gt;使用IDA64打开kernel文件，选择&lt;code&gt;ARM Little-endian [ARM]&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;4.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;5.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通常都在ARM64中，将kernel文件偏移0x1000加载到内存的0xffffffc000080000处：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;6.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;armv7的内核:74e08c5c20c35fafeb119b7ae5ebabe7&#34;&gt;ARMv7的内核&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;7.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;8.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;步骤3-为ida中的内核增加符号支持:74e08c5c20c35fafeb119b7ae5ebabe7&#34;&gt;步骤3. 为IDA中的内核增加符号支持&lt;/h1&gt;

&lt;p&gt;以下脚本通过&lt;code&gt;cat /proc/kallsyms&lt;/code&gt;的输出结果来对IDA中的内核函数sub_xxx进行重命名:&lt;/p&gt;

&lt;p&gt;(由于某个早期版本Android已经不再输出内核符号偏移地址全部以0填充，所以使用该方法前 需要修改kernel使其输出偏移地址。)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;// 使用一下IDA脚本(python)，将函数/符号名设到对应的sub_xxx上
ksyms = open(&amp;quot;syms.txt&amp;quot;) 
i = 0 
for line in ksyms: 
    i += 1 
    addr = int(line[0:8],16)  
    name = line[11:-1]  
    idaapi.set_debug_name(addr,name)  
    MakeNameEx(addr,name,SN_NOWARN)
    add_func(addr)
    if i % 100 == 0:
        Message(&amp;quot;cur: %d\n&amp;quot; % i)
    # Message(&amp;quot;%08X:%sn&amp;quot;%(addr,name))  
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;注意事项:74e08c5c20c35fafeb119b7ae5ebabe7&#34;&gt;注意事项&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;kernel加载地址的寻找：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以上的kernel加载地址0xffffffc000080000只是比较普遍的情况，如果以上地址不能正确分析，也有两个方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可利用&lt;code&gt;cat /proc/kallsyms&lt;/code&gt;输出的符号与IDA中的函数进行结合分析，尝试推算出加载地址。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过代码中对字符串的引用来推算出加载地址。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过内核源文件：boot/boardconfig.h中宏配置寻找内核加载地址。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;文件偏移的寻找&lt;/strong&gt;
开头处寻找不为00的数据：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;9.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;加载后，默认为DCB数据，可以用一下脚本自动刷成代码：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;10.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#! python
def main():
    start = AskAddr(MinEA(), &amp;quot;欲转为Code的起始地址：&amp;quot;)
    end = AskAddr(MinEA(), &amp;quot;欲转为Code的结束地址：&amp;quot;)
    if start &amp;gt;= end:
        print(&#39;输入的区间不正确～&#39;)
        return

    for cur_addr in range(start, end, 4):
        flags = GetFlags(cur_addr)
        print(&amp;quot;[MSG] 0x%X &#39;s flags: %x&amp;quot; % (cur_addr, flags))
        if Byte(cur_addr) and not (isCode(flags) and isTail(flags) and isUnknown(flags) and isHead(flags)):
            print(&#39;[MSG] 0x%X is Data, Make to code.&#39; % cur_addr)
            MakeCode(cur_addr)
main()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;参考资料:74e08c5c20c35fafeb119b7ae5ebabe7&#34;&gt;参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/qq1084283172/article/details/57074695&#34;&gt;http://blog.csdn.net/qq1084283172/article/details/57074695&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.hhjack.com/arm64_zimage_reverseengineering_with_ida_pro/&#34;&gt;http://www.hhjack.com/arm64_zimage_reverseengineering_with_ida_pro/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cnx-software.com/2015/12/07/how-to-extract-kernel-img-with-mkboot-script/&#34;&gt;https://www.cnx-software.com/2015/12/07/how-to-extract-kernel-img-with-mkboot-script/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>王者荣耀荣耀C#脚本的提取</title>
      <link>https://pkiller.com/android/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80CSharp%E8%84%9A%E6%9C%AC%E7%9A%84%E6%8F%90%E5%8F%96/</link>
      <pubDate>Thu, 26 Apr 2018 11:07:43 +0800</pubDate>
      
      <guid>https://pkiller.com/android/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80CSharp%E8%84%9A%E6%9C%AC%E7%9A%84%E6%8F%90%E5%8F%96/</guid>
      <description>

&lt;p&gt;王者荣耀采用流行的Unity3d框架开发，主要游戏逻辑使用C#编写， 但目前尚未确认是否有使用到Lua。&lt;/p&gt;

&lt;h2 id=&#34;一-关于unity3d:f2902e0ae70def3075b11d65b413adb2&#34;&gt;一、关于Unity3D&lt;/h2&gt;

&lt;p&gt;Unity3D是一款专用于3D游戏开发的跨平台框架，支持Lua、C#、JS脚本语言开发游戏逻辑。但目前使用较为广泛的还是C#，&lt;code&gt;王者荣耀使用的正是C#&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;二-unity3d-with-c-手游的通用修改方案:f2902e0ae70def3075b11d65b413adb2&#34;&gt;二、Unity3D with C#手游的通用修改方案&lt;/h2&gt;

&lt;p&gt;Unity3D只是提供3D框架，其对C#脚本的支持能力完全依赖开源项：&lt;/p&gt;

&lt;p&gt;mono (&lt;a href=&#34;https://github.com/mono/mono&#34;&gt;https://github.com/mono/mono&lt;/a&gt;, &lt;code&gt;在apk的lib下面有一个名为libmono.so就是使用了mono项目的特征&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pkiller.com/android/王者荣耀CSharp脚本的提取/1.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Unity3D编译好后，最终的C#文件保存在&lt;code&gt;×.apk/assets/bin/Data/Managed/中的Assembly-CSharp.dll&lt;/code&gt; 和 &lt;code&gt;Assembly-Csharp-firstpass.dll&lt;/code&gt; 两个文件，其都是编译好的C#文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pkiller.com/android/王者荣耀CSharp脚本的提取/2.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;对Unity3D游戏逻辑的修改最后就是针对以上这两个dll文件，&lt;code&gt;这两个dll文件是windows上的PE格式&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pkiller.com/android/王者荣耀CSharp脚本的提取/3.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;正常无保护的情况下可以很明显的看出以上两个文件的特征，使用一些C#的反编译工具(如:&lt;code&gt;.Net Reflector、ILSpy&lt;/code&gt;)可以很容易的得到源码逻辑：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pkiller.com/android/王者荣耀CSharp脚本的提取/4.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后利用如.NetReflector工具对 dll文件中的游戏逻辑做修改，并替换dll文件后打包。便完成了游戏的修改。&lt;/p&gt;

&lt;h2 id=&#34;三-对王者荣耀进行分析:f2902e0ae70def3075b11d65b413adb2&#34;&gt;三、对王者荣耀进行分析&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1. 在王者荣耀中，这两个文件(&lt;code&gt;Assembly-CSharp.dll&lt;/code&gt; 和 &lt;code&gt;Assembly-Csharp-firstpass.dll&lt;/code&gt;)均被加密保护，已经无法看到标准的PE头。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pkiller.com/android/王者荣耀CSharp脚本的提取/5.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. C#解析引擎libmono.so也被加壳混淆。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pkiller.com/android/王者荣耀CSharp脚本的提取/6.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 游戏存在反调试保护，无法用断点断到关键函数，会自动退出。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据阅读mono开源项目得知其的加载assembly文件的方法名为：&lt;/p&gt;

&lt;p&gt;mono_image_open_from_data_with_name(&lt;code&gt;char *data, guint32 data_len&lt;/code&gt;, gboolean need_copy, MonoImageOpenStatus *status, gboolean refonly, const char *name)&lt;/p&gt;

&lt;p&gt;并且该函数在libmono.so中对外导出&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第1个参数data, 指向的是Assembly-*.dll的完整文件数据。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第2个参数是data_len，是数据长度。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先查看libmono.so中的&lt;code&gt;mono_image_open_from_data_with_name&lt;/code&gt;导出函数，发现已被加密混淆。怀疑TX可能对mono做了特殊的定制(如果是的话会比较棘手)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 通过进程注入对libmono.so脱壳还原代码后发现并无特殊定制：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;说明调用到&lt;code&gt;mono_image_open_from_data_with_name&lt;/code&gt;后参数中的一定是明文dll数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pkiller.com/android/王者荣耀CSharp脚本的提取/7.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;既然没有定制libmono.so，所以直接采用hook方式进行(可使用开源项目adbi、或自己开发)hook这个函数(&lt;code&gt;mono_image_open_from_data_with_name&lt;/code&gt;)
但由于Assembly-*.dll文件在游戏启动时就被加载，所以需要考虑hook时机：&lt;/p&gt;

&lt;p&gt;1.使用debug模式启动王者荣耀，使其处于等待调试状态&amp;hellip;&lt;/p&gt;

&lt;p&gt;2.先hook住libc.so中的__openat函数，当发现有Assembly-*.dll文件被打开时，再对libmono.so中的&lt;code&gt;mono_image_open_from_data_with_name&lt;/code&gt;挂钩，这样可以保证hook不错过时机，并且外壳代码已经还原完毕。&lt;/p&gt;

&lt;p&gt;3.最后将&lt;code&gt;mono_image_open_from_data_with_name&lt;/code&gt; 的数据写出文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. DUMP成功后的脚本，使用反编译工具可以看到游戏逻辑，并可以修改：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pkiller.com/android/王者荣耀CSharp脚本的提取/8.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;本次分析验证到此。&lt;/p&gt;

&lt;h2 id=&#34;四-基于此开发辅助工具的一点思路:f2902e0ae70def3075b11d65b413adb2&#34;&gt;四、基于此开发辅助工具的一点思路&lt;/h2&gt;

&lt;p&gt;定位到游戏关键逻辑后（如：地图全亮）。使用C#反编译修改工具(如:&lt;code&gt;.Net Reflector、ILSpy&lt;/code&gt;)对脚本进行修改。最后利用hook将修改后的脚本替换到内存中去，让游戏使用新的脚本。即可达成修改游戏逻辑的目的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>改造linker, 实现无痕加载so模块</title>
      <link>https://pkiller.com/android/%E6%94%B9%E9%80%A0linker,%20%E5%AE%9E%E7%8E%B0%E6%97%A0%E7%97%95%E5%8A%A0%E8%BD%BDso%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Wed, 11 Apr 2018 10:06:24 +0800</pubDate>
      
      <guid>https://pkiller.com/android/%E6%94%B9%E9%80%A0linker,%20%E5%AE%9E%E7%8E%B0%E6%97%A0%E7%97%95%E5%8A%A0%E8%BD%BDso%E6%A8%A1%E5%9D%97/</guid>
      <description>

&lt;p&gt;最近研究了一些防内存检测方面的姿势, 异常so模块检测在对抗中占了挺重要的部分.
    由于&lt;code&gt;Bionic/linker&lt;/code&gt;完全是一个用户态的实现, 所以就想着对linker的代码做一番改造, 实现一个自己的so loader, 目的是隐藏so模块,躲过检测.&lt;/p&gt;

&lt;p&gt;目前遍历进程内已加载模块的方法大概有两个:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;遍历soinfo-&amp;gt;next(本身为一个环形链表).&lt;/li&gt;
&lt;li&gt;读取/proc/pid/maps.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;涉及的核心逻辑主要在: &lt;code&gt;linker.cpp&lt;/code&gt;与&lt;code&gt;linker_phdr.cpp&lt;/code&gt;两个文件中, &lt;code&gt;linker_phdr.cpp&lt;/code&gt;负责elf内存的映射与读取, &lt;code&gt;linker.cpp&lt;/code&gt;主要负责对数据进行展开和初始化.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;linker里面涉及的引用比较多,弄了很久才剥离出来,最后修修补补,提取出了以下几个必须的文件:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    elf_machdep.h 
    diy_exec_elf.h 
    diy_linker.cpp 
    diy_linker.h 
    diy_linker_phdr.cpp 
    diy_linker_phdr.h 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在linker中是不允许调用&lt;code&gt;malloc&lt;/code&gt;,&lt;code&gt;free&lt;/code&gt;等函数的. 这是因为linker作为第一个被加载的模块(早于libc.so),所以可用资源方面比较严苛, 从代码中的一段注释可以得知原因:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* &amp;gt;&amp;gt;&amp;gt; IMPORTANT NOTE - READ ME BEFORE MODIFYING &amp;lt;&amp;lt;&amp;lt;
 *
 * Do NOT use malloc() and friends or pthread_*() code here.
 * Don&#39;t use printf() either; it&#39;s caused mysterious memory
 * corruption in the past.
 * The linker runs before we bring up libc and it&#39;s easiest
 * to make sure it does not depend on any complex libc features
 *
 * open issues / todo:
 *
 * - are we doing everything we should for ARM_COPY relocations?
 * - cleaner error reporting
 * - after linking, set as much stuff as possible to READONLY
 *   and NOEXEC
 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然上面列举了linker中的诸多限制, 但是这仅仅是对于原生linker而言. 而我们自己改造的linker在使用时周围的资源已经是非常丰富了, libc等各种库基本都已经加载完毕. 所以可以放开手脚的干一番.  废话不多, 下面开始干活.&lt;/p&gt;

&lt;h1 id=&#34;第一步-改造各种输出宏定义:29bc7b3984f30f3a453cada00f5708d0&#34;&gt;第一步: 改造各种输出宏定义.&lt;/h1&gt;

&lt;p&gt;linker中有很多不同种类的调试信息输出宏, 我并不想一次性删除, 因为这些输出对后面的调错还有很大帮助, 毕竟linker里的逻辑还是比较复杂的. 我全部都用__android_log_print():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// linker.h

#define DL_ERR(x...) __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;linker_ERR&amp;quot;, x);

#define DL_WARN(fmt, x...) __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;linker_WARN&amp;quot;, fmt, x);

#define DL_TRACE(fmt, x...) __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;linker_TRACE&amp;quot;, fmt, x);

#define TRACE_TYPE(x, y...) __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;linker_TRACE_TYPE&amp;quot;, y);

#define DEBUG(x...) __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;linker_DEBUG&amp;quot;, x);

#define INFO(x...) __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;linker_INFO&amp;quot;, x);

#define LOOKUP 1  // 某个宏...作用忘了

#define __libc_format_buffer(b, s, f, p...) sprintf(b, f, p);     // 这里用sprintf代替, 否则就要把libc里面的一大堆文件剥离出来, 不建议入坑.
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;第二步-替换dt-need的依赖加载:29bc7b3984f30f3a453cada00f5708d0&#34;&gt;第二步: 替换DT_NEED的依赖加载&lt;/h1&gt;

&lt;p&gt;在static bool soinfo_link_image(soinfo* si)函数的后半段，有一处代码是遍历DT_NEED并加载依赖库的代码，这里将代码直接替换成dlopen(), 调用原生linker来加载依赖库.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// linker.cpp
  if (dynamic != NULL) {
    for (Elf32_Dyn* d = dynamic; d-&amp;gt;d_tag != DT_NULL; ++d) {
      if (d-&amp;gt;d_tag == DT_NEEDED) {
        const char* library_name = strtab + d-&amp;gt;d_un.d_val;
        TRACE(&amp;quot;\&amp;quot;%s\&amp;quot;: calling constructors in DT_NEEDED \&amp;quot;%s\&amp;quot;&amp;quot;, name, library_name);
        find_loaded_library(library_name)-&amp;gt;CallConstructors();
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改后为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for (Elf32_Dyn* d = si-&amp;gt;dynamic; d-&amp;gt;d_tag != DT_NULL; ++d) {
        if (d-&amp;gt;d_tag == DT_NEEDED) {
            const char* library_name = si-&amp;gt;strtab + d-&amp;gt;d_un.d_val;
            DEBUG(&amp;quot;%s needs %s&amp;quot;, si-&amp;gt;name, library_name);
            soinfo* lsi = (soinfo*)dlopen(library_name, 0);       // 加载其他依赖的so, 这里直接调用原生linker
            if (lsi == NULL) {
                strlcpy(tmp_err_buf, linker_get_error_buffer(), sizeof(tmp_err_buf));
                DL_ERR(&amp;quot;could not load library \&amp;quot;%s\&amp;quot; needed by \&amp;quot;%s\&amp;quot;; caused by %s&amp;quot;,
                       library_name, si-&amp;gt;name, tmp_err_buf);
                return false;
            }
            *pneeded++ = lsi;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;第三步-去除soinfo链:29bc7b3984f30f3a453cada00f5708d0&#34;&gt;第三步: 去除soinfo链.&lt;/h1&gt;

&lt;p&gt;该链作为原生linker中的一条很关键的结构, 每个加载的soinfo都会被串到这条链上来. 去除soinfo链后我们加载的模块就无法被通过遍历soinfo链表检测到.
先删除掉以下变量定义, 编译一把使引用部位报错, 然后一点点清理.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// linker.cpp
static struct soinfo_pool_t* gSoInfoPools = NULL;
static soinfo* gSoInfoFreeList = NULL;
static soinfo* solist = &amp;amp;libdl_info;
static soinfo* sonext = &amp;amp;libdl_info;
static soinfo* somain; /* main process, always the one after libdl_info */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一处关键的引用在函数&lt;code&gt;soinfo_alloc&lt;/code&gt;中, 这里用于分配新的&lt;code&gt;soinfo&lt;/code&gt;空间:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;static soinfo* soinfo_alloc(const char* name) {
  if (strlen(name) &amp;gt;= SOINFO_NAME_LEN) {
    DL_ERR(&amp;quot;library name \&amp;quot;%s\&amp;quot; too long&amp;quot;, name);
    return NULL;
  }

  if (!ensure_free_list_non_empty()) {
    DL_ERR(&amp;quot;out of memory when loading \&amp;quot;%s\&amp;quot;&amp;quot;, name);
    return NULL;
  }

  // Take the head element off the free list.
  soinfo* si = gSoInfoFreeList;
  gSoInfoFreeList = gSoInfoFreeList-&amp;gt;next;

  // Initialize the new element.
  memset(si, 0, sizeof(soinfo));
  strlcpy(si-&amp;gt;name, name, sizeof(si-&amp;gt;name));
  sonext-&amp;gt;next = si;
  sonext = si;

  TRACE(&amp;quot;name %s: allocated soinfo @ %p&amp;quot;, name, si);
  return si;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们剥离了全局的soinfo链, 所以这里清理掉相关代码, 直接用&lt;code&gt;malloc&lt;/code&gt;代替, 修改后的&lt;code&gt;soinfo_alloc&lt;/code&gt;如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;static soinfo* soinfo_alloc(const char* name) {
  if (strlen(name) &amp;gt;= SOINFO_NAME_LEN) {
    DL_ERR(&amp;quot;library name \&amp;quot;%s\&amp;quot; too long&amp;quot;, name);
    return NULL;
  }

  if (!ensure_free_list_non_empty()) {
    DL_ERR(&amp;quot;out of memory when loading \&amp;quot;%s\&amp;quot;&amp;quot;, name);
    return NULL;
  }

  // Initialize the new element. 
  // 以下是我们修改后的代码, 我这里直接用了new ....嘿嘿. 
  soinfo *si = new soinfo();
  memset(si, 0, sizeof(soinfo));
  strlcpy(si-&amp;gt;name, name, sizeof(si-&amp;gt;name));
  DL_TRACE(&amp;quot;name %s: allocated soinfo @ %p&amp;quot;, name, si);
  return si;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;第四步-从-proc-pid-maps中隐藏map信息:29bc7b3984f30f3a453cada00f5708d0&#34;&gt;第四步: 从/proc/pid/maps中隐藏map信息&lt;/h1&gt;

&lt;p&gt;很多的对抗行为都发生在&lt;strong&gt;/proc/pid/&lt;/strong&gt;目录下, 对于模块检测来说&lt;code&gt;maps&lt;/code&gt;一定是非常重要的检测点. 所以下面我们修改代码, 不让模块信息出现在&lt;code&gt;maps&lt;/code&gt;中.
首先理清原理: 之所以能在maps文件中看到模块信息, 是因为linker在加载so时使用&lt;code&gt;mmap(xx, xx, xx, xx, fd_, xx)&lt;/code&gt;映射了so文件的fd(文件描述符). 这个操作会被内核记录下来体现在&lt;code&gt;maps&lt;/code&gt;中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// linker_phdr.cpp

// Map all loadable segments in process&#39; address space.
// This assumes you already called phdr_table_reserve_memory to
// reserve the address space range for the library.
// TODO: assert assumption.
bool ElfReader::LoadSegments() {
...
    if (file_length != 0) {
      void* seg_addr = mmap((void*)seg_page_start,
                            file_length,
                            PFLAGS_TO_PROT(phdr-&amp;gt;p_flags),
                            MAP_FIXED|MAP_PRIVATE,
                            fd_,    // 就是这个参数....
                            file_page_start);
      if (seg_addr == MAP_FAILED) {
        DL_ERR(&amp;quot;couldn&#39;t map \&amp;quot;%s\&amp;quot; segment %d: %s&amp;quot;, name_, i, strerror(errno));
        return false;
      }
    }
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面我们必须改变直接映射fd的方式, 并且还不影响原有功能, 思路为: 先mmap一块无fd内存, 然后使用read读出so指定偏移内容填充到mmap的内存处, 最后将mmap的内存属性设置为segment的属性. 代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;bool ElfReader::LoadSegments() {
    if (file_length != 0) {
       // 修改后: 
       void* seg_addr = mmap((void*)seg_page_start,
                              file_length,
                              PROT_WRITE|PROT_READ,
                              MAP_FIXED|MAP_PRIVATE| MAP_ANONYMOUS,
                              0,  // 不直接映射文件...
                              0);
      if (seg_addr == MAP_FAILED) {
         DL_ERR(&amp;quot;couldn&#39;t mmap1 \&amp;quot;%s\&amp;quot; segment %d: %s&amp;quot;, name_, i, strerror(errno));
         return false;
      }
      if(lseek( fd_ , file_page_start, SEEK_SET ) == -1L ) { // 移动到当前segment处
          DL_ERR(&amp;quot;couldn&#39;t lseek1 \&amp;quot;%s\&amp;quot; segment %d: %s&amp;quot;, name_, i, strerror(errno));
          return -1;
      }
      if(-1 == read(fd_, seg_addr, file_length)) { // 读出内容到mmap出的缓存区
          DL_ERR(&amp;quot;couldn&#39;t read \&amp;quot;%s\&amp;quot; segment %d: %s&amp;quot;, name_, i, strerror(errno));
          return -1;
      }
      if( -1 == mprotect(seg_addr, file_length, PFLAGS_TO_PROT(phdr-&amp;gt;p_flags))) { // 根据文件内容设置内存属性.
          DL_ERR(&amp;quot;couldn&#39;t mprotect \&amp;quot;%s\&amp;quot; segment %d: %s&amp;quot;, name_, i, strerror(errno));
          return -1;
      }
      DL_INFO(&amp;quot;LoadSegments succeed:%s!&amp;quot;, name_);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;具体思路如上-nexus-5-4-4-4-下测试通过-对linker了解不深-如果有偏差和错误还请大家指正-附上代码:29bc7b3984f30f3a453cada00f5708d0&#34;&gt;具体思路如上, &lt;code&gt;nexus 5&lt;/code&gt;+ &lt;code&gt;4.4.4&lt;/code&gt;下测试通过.  对linker了解不深, 如果有偏差和错误还请大家指正. 附上代码:~&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://bbs.pediy.com/thread-216119.htm&#34;&gt;https://bbs.pediy.com/thread-216119.htm&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ARMv8代码定式</title>
      <link>https://pkiller.com/android/ARMv8%E4%BB%A3%E7%A0%81%E5%AE%9A%E5%BC%8F/</link>
      <pubDate>Mon, 23 Oct 2017 16:42:28 +0800</pubDate>
      
      <guid>https://pkiller.com/android/ARMv8%E4%BB%A3%E7%A0%81%E5%AE%9A%E5%BC%8F/</guid>
      <description>

&lt;p&gt;本文案例默认编译自&lt;code&gt;android-ndk-r10d&lt;/code&gt;, 并且编译选项的均为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;APP_OPTIM := release  
OPT_CFLAGS := -O2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若为其它ndk环境将会在小节开头处有特殊说明.&lt;/p&gt;

&lt;h1 id=&#34;一-成员函数:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;一. 成员函数&lt;/h1&gt;

&lt;h2 id=&#34;a-参数传递:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;a. 参数传递&lt;/h2&gt;

&lt;h1 id=&#34;二-全局变量引用:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;二. 全局变量引用&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;const char g_str0[] = &amp;quot;hello world 0~&amp;quot;;
const char g_str1[] = &amp;quot;hello world 1~&amp;quot;;
const char g_str2[] = &amp;quot;hello world 2~&amp;quot;;
int main(int argc, char *argv[])
{
    printf(g_str0);
    printf(g_str1);
    printf(g_str2);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;objdump:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adrp    x19, 11000      ; 这里的0x11000指向的是.data数据区
add     x19, x19, #0x10 ; .data+0x10, 定位到&amp;quot;hello world 0~&amp;quot;
mov     x0, x19
bl      590 &amp;lt;printf@plt&amp;gt;
add     x0, x19, #0x10  ; .data+0x20, 定位到&amp;quot;hello world 1~&amp;quot;
bl      590 &amp;lt;printf@plt&amp;gt;
add     x0, x19, #0x20  ; .data+0x30, 定位到&amp;quot;hello world 2~&amp;quot;
bl      590 &amp;lt;printf@plt&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果变量之间有相邻关系, 编译器会定位首个变量位置, 然后进行叠加定位.&lt;/p&gt;

&lt;p&gt;上面的三个string长度为0xF,但3次累加偏移均为0x10. 原因是编译器布置数据的ALGIN值为0x10, 有利于更快访问内存.&lt;/p&gt;

&lt;h1 id=&#34;三-局部静态变量引用:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;三. 局部静态变量引用&lt;/h1&gt;

&lt;p&gt;下面的代码修改自&lt;code&gt;全局变量引用&lt;/code&gt;,修改的部分只是将全局变量移入函数体并加入static修饰符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int main(int argc, char *argv[])
{
    static char g_str0[] = &amp;quot;hello world 0~&amp;quot;;
    static char g_str1[] = &amp;quot;hello world 1~&amp;quot;;
    static char g_str2[] = &amp;quot;hello world 2~&amp;quot;;
    printf(g_str0);
    printf(g_str1);
    printf(g_str2);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;objdump:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; 编译后的结果与`全局变量引用`中的汇编完全相同.
adrp    x19, 11000
add     x19, x19, #0x10
mov     x0, x19
bl      590 &amp;lt;printf@plt&amp;gt;
add     x0, x19, #0x10
bl      590 &amp;lt;printf@plt&amp;gt;
add     x0, x19, #0x20
bl      590 &amp;lt;printf@plt&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;局部静态变量与全局变量无本质区别, 二者数据都存放于.data段.&lt;/p&gt;

&lt;h1 id=&#34;四-常数合并:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;四. 常数合并&lt;/h1&gt;

&lt;p&gt;表达式中存在多个常量的情况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int n = 1 + 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;objdump:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mov    w0, #0x2         ; 编译期间已得出结果.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;无论release(O2)还是debug对于简单表达式均会在编译期间计算完成.&lt;/p&gt;

&lt;h1 id=&#34;五-乘法:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;五. 乘法&lt;/h1&gt;

&lt;h2 id=&#34;a-2的幂:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;a. 2的幂&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;int a = (int)argc * 4;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ida:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UBFM    W1, W0, #0x1E, #0x1D
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;objdump:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LSL    W1, W0, #2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于是乘2的幂, 所以可理解为左移. 左移不需要考虑符号位, 所以使用UBFM系列. ida与objdump解析差异请详见: &lt;code&gt;xBFM的别名转换与识别&lt;/code&gt;小节.&lt;/p&gt;

&lt;h2 id=&#34;b-非2的幂:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;b. 非2的幂&lt;/h2&gt;

&lt;h3 id=&#34;a-乘数-1后为2的幂:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;a). 乘数+1后为2的幂&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;int a = (int)argc * 15;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ida:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; W0 为 argc 
UBFM    W1, W0, #0x1C, #0x1B
SUB     W1, W1, W0

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据 &lt;code&gt;xBFM的别名转换与识别&lt;/code&gt;可转换为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LSL    W1, W0, #4    ;  a = argc * 16
SUB    W1, W1, W0   ;  a = a - argc
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;b-乘数-1后为2的幂:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;b). 乘数-1后为2的幂&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;int a = (int)argc * 17;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ida:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ADD    W1, W0, W0,LSL#4 ; a = argc*16 + argc
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;c-乘数-2-1为2的幂:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;c). 乘数/2-1为2的幂&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;int a = (int)argc * 10;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ida:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; W0 为 argc 
ADD     W1, W0, W0,LSL#2
UBFM    W1, W1, #0x1F, #0x1E
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转换为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ADD    W1, W0, W0,LSL#2  ; a = argc * 5 
LSL    W1, W1, #1        ; a = a * 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;d-乘数-2-x-1-2-y-x-或-乘数-2-x-1-2-y-x-1:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;d). &lt;code&gt;乘数 = (2^x+1) * 2^(y-x)&lt;/code&gt;  或  &lt;code&gt;乘数 = (2^x+1) * 2^(y-x) + 1&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;满足以下条件, m为乘数, y值为满足&amp;quot;大于并最接近m的 2的n次幂数&amp;quot;的n: 
x的值为满足以下等式的值, 需要遍历尝试, 遍历范围为0到y:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;m=(2x+1)∗2(y−x)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;或&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;m=(2x+1)∗2(y−x)+1&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int a = (int)argc * 1041; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ida解析:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; W0 = argc = m = 1041
; x = 10 = 6+4
ADD    W1, W0, W0,LSL#6  ; 65 = (2^6 + 1)
ADD    W1, W0, W1,LSL#4  ; 1041= 65 * 2^4 + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;gcc优化乘法总结:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;GCC优化乘法总结&lt;/h2&gt;

&lt;p&gt;该节的乘法优化针对变量*常量的情况.  因为&lt;code&gt;常量*常量&lt;/code&gt;会在编译器计算, &lt;code&gt;变量*变量&lt;/code&gt;会直接使用MUL指令.&lt;/p&gt;

&lt;p&gt;GCC针对乘法优化方式的采用优先级为:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;2的n次幂&lt;/code&gt; &amp;gt; &lt;code&gt;乘数-1=2^n&lt;/code&gt;/&lt;code&gt;乘数+1=2^n&lt;/code&gt; &amp;gt; &lt;code&gt;乘数=(2^x+1)*(2^(y-x))&lt;/code&gt;/&lt;code&gt;乘数=(2^x+1)*(2^(y-x))+1&lt;/code&gt; &amp;gt; &lt;code&gt;不适合所有优化方式,使用MUL指令&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;六-除法:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;六. 除法&lt;/h1&gt;

&lt;h2 id=&#34;a-2的幂-1:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;a. 2的幂&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;int a = (int)argc / 4;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ida解析:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SBFM    W1, W2, #2, #0x1F
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;objdump解析:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;asr     w1, w2, #2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于除数是2的幂, 所以可理解为右移. 若被除数是有符号数需要考虑符号位, 所以使用SBFM. 详见&lt;code&gt;xBFM的别名转换与识别&lt;/code&gt;小节.&lt;/p&gt;

&lt;h1 id=&#34;七-xbfm的别名转换与识别:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;七. xBFM的别名转换与识别&lt;/h1&gt;

&lt;p&gt;Unsigned Bitfield Move / Signed Bitfield Move&lt;/p&gt;

&lt;p&gt;32bit: &lt;code&gt;XBFM &amp;lt;Wd&amp;gt;, &amp;lt;Wn&amp;gt;, #&amp;lt;immr&amp;gt;, #&amp;lt;imms&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;64bit: &lt;code&gt;XBFM &amp;lt;Xd&amp;gt;, &amp;lt;Xn&amp;gt;, #&amp;lt;immr&amp;gt;, #&amp;lt;imms&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;举例来说, 在arm指令手册中, LSL、LSR、UBFIZ、UBFX、UXTB、UXTH都属于UBFM的别名, 也就是说指令编码是完全相同的. 具体解析方式根据反汇编工具的具体策略而视. 如上:《IDA》中直接将所有情况解析为能概括所有情况的UBFM. 但是在《objdump》中会根据情况将其解析为最符合使用意图的别名. LSL或LSR实际上属于UBFM的子集. 换言之LSL或LSR可以被UBFM概括.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-lsl-lsr-asr:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;a. LSL、LSR/ASR&lt;/h2&gt;

&lt;p&gt;识别特征(这里直接通过操作数的特征来转为易读的汇编形式(属于土方子), 正规的方式在指令手册有详细描述):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (is_word) // is Wx
{
  if (immr-imms == 1){
    type = TP_LSL;
    printf (&amp;quot;LSL %s, %s, #%d&amp;quot;, $Wd, $Wn, 32-$immr);
  }else if (immr &amp;lt;= 0x1F &amp;amp;&amp;amp; imms == 0x1F){
    type =  (is_SBFM? TP_ASR : TP_LSR);  // LSR or ASR
    printf (&amp;quot;%cSR %s, %s, #%d&amp;quot;, (is_SBFM?&#39;A&#39;:&#39;L&#39;), $Wd, $wn, $immr);
  }else{
    type = TP_OTHER;
  }
}
else if (is_Xword)
{
  // ...
  if ((imms == 0x1F &amp;amp;&amp;amp; immr &amp;gt; 0x1F) || immr-imms == 1){
    /*
      LSL (&amp;lt;=32bit number) 左移位数小于等于32, 产生特征为: (imms == 0x1F &amp;amp;&amp;amp; immr &amp;gt; 0x1F)
      LSL (&amp;gt;32bit number)  左移位数大于32, 产生特诊为: (immr-imms == 1)
     */
    type = TP_LSL;
    printf(&amp;quot;LSL %s, %s, #%d&amp;quot;, $Xd, $Xn, 64-$immr);
  }else if (immr &amp;lt;= 0x3F &amp;amp;&amp;amp; imms == 0x3F ){
    type = (is_SBFM? TP_ASR : TP_LSR);
    printf(&amp;quot;%cSR %s, %s, $%d&amp;quot;, (is_SBFM?&#39;A&#39;:&#39;L&#39;), $Xd, $Xn, $immr);
  }else{
    type = TP_OTHER;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;举例1, 有如下IDA汇编:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UBFM    W1, W0, #0x1E, #0x1D
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可利用转化规则&lt;code&gt;LSL  W1, W0, #($32-immr)&lt;/code&gt;, 得到如下LSL结果:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LSL    W1, W0, #2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;举例2, 有如下IDA汇编:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SBFM    W1, W0, #2, #0x1F
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以利用转化规则&lt;code&gt;ASR  W1, W0, $immr&lt;/code&gt; (因为是Signed Bitfield Move, 所以转为ASR), 得到如下ASR结果:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ASR    W1, W0, #2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;举例3, 有如下IDA汇编:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UBFM    X1, X0, #0x21, #0x20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可利用转化规则&lt;code&gt;LSL  X1, X0, #($64-immr)&lt;/code&gt;, 得到如下LSL结果:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LSL    X1, X0, #31
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;举例4, 有如下IDA汇编:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SBFM    X1, X0, #0x32, #0x3F
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可利用转化规则&lt;code&gt;ASL  X1, X0, $immr&lt;/code&gt;, 得到如下ASR (因为是SBFM, 所以采用ASR)结果:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ASR    X1, X0, #50
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;八-类:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;八.类&lt;/h1&gt;

&lt;p&gt;本节以如下代码为例展开分析：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;jni.h&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;android/log.h&amp;gt;

class SuperA{
public:
   int value_a;

   SuperA(){
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;SuperA::SuperA()&amp;quot;);
   }
   virtual ~SuperA(){
       this-&amp;gt;value_a = 0;
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;SuperA::~SuperA()&amp;quot;);
   }
   virtual int fun1
           (int a){
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;SuperA::fun1()&amp;quot;);
       return a + 1;
   }
   virtual int fun2(int a){
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;SuperA::fun2()&amp;quot;);
       this-&amp;gt;value_a = a + 1;
       return a + 1;
   }
   virtual int testA(int a){
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;SuperA::testA()&amp;quot;);
       this-&amp;gt;value_a = a + 2;
       return a + 2;
   }
};

class SuperB{
public:
   int value_b;

   SuperB(){
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;SuperB::SuperB()&amp;quot;);
   }
   virtual ~SuperB(){
       this-&amp;gt;value_b = 0;
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;SuperB::~SuperB()&amp;quot;);
   }
   virtual int fun1(int a){
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;SuperB::fun1()&amp;quot;);
       return a + 1;
   }
   virtual int fun2(int a){
        __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;SuperB::fun2()&amp;quot;);
       return a + 2;
   }
   virtual int testB1(int a){
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;SuperB::testB1()&amp;quot;);
       return a + 1;
   }
   virtual int testB2(int a){
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;SuperB::testB2()&amp;quot;);
       this-&amp;gt;value_b = a+1;
       return a + 1;
   }
};

class SuperC{
public:
   int value_c;

   SuperC(){
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;SuperC::SuperC()&amp;quot;);
   }
   virtual ~SuperC(){
       this-&amp;gt;value_c = 0;
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;SuperC::~SuperC()&amp;quot;);
   }
   virtual int fun1(int a){
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;SuperC::fun1()&amp;quot;);
       return a + 1;
   }
   virtual int fun2(int a){
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;SuperC::fun2()&amp;quot;);
       return a + 2;
   }
   virtual int testC1(int a){
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;SuperC::testC1()&amp;quot;);
       this-&amp;gt;value_c = a+1;
       return a + 1;
   }
   virtual int testC2(int a){
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;SuperC::testC2()&amp;quot;);
       this-&amp;gt;testC3(123);
       return a + 1;
   }
   virtual int testC3(int a) = 0;
};


class Sub: public SuperA, public SuperB, public SuperC{
public:
   int value_sub;

   Sub(){
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;Sub::Sub()&amp;quot;);
   }
   virtual ~Sub(){
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;Sub::~Sub()&amp;quot;);
   }
   virtual int fun1(int a){
        __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;Sub::fun1()&amp;quot;);
       return a + 1 + 1;
   }
   virtual int fun2(int a){
        __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;Sub::fun2()&amp;quot;);
       this-&amp;gt;value_sub = a + 2 + 2;
       return a + 2 + 2;
   }
   virtual int fun3(int a){
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;Sub::fun3()&amp;quot;);
       SuperC::testC1(1);
       return a + 3;
   }
   virtual int fun4(int a){
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;Sub::fun4()&amp;quot;);
       return a + 23;
   }
   virtual int testC3(int a){
       __android_log_print(ANDROID_LOG_DEBUG, &amp;quot;c++&amp;quot;, &amp;quot;Sub::testC3()&amp;quot;);
       return a + 23;
   }
};

extern &amp;quot;C&amp;quot;
JNIEXPORT jstring JNICALL
Java_cplusplus_1test_example_com_myapplication_MainActivity_stringFromJNI(
       JNIEnv *env,
       jobject /* this */) {
   std::string hello = &amp;quot;Hello from C++&amp;quot;;

   Sub *sub = new Sub();
   sub-&amp;gt;fun1((int)env-&amp;gt;GetVersion());
   sub-&amp;gt;fun2((int)env-&amp;gt;GetVersion());
   sub-&amp;gt;fun3((int)env-&amp;gt;GetVersion());
   sub-&amp;gt;fun4((int)env-&amp;gt;GetVersion());
   sub-&amp;gt;testA((int)env-&amp;gt;GetVersion());
   sub-&amp;gt;testB1((int)env-&amp;gt;GetVersion());
   sub-&amp;gt;testC1((int)env-&amp;gt;GetVersion());

   delete sub;

   return env-&amp;gt;NewStringUTF(hello.c_str());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;以上代码中4个class的关系如下所示，&lt;code&gt;SuperA,..B,..C&lt;/code&gt;被&lt;code&gt;Sub&lt;/code&gt;继承, 并且所有class均有&lt;code&gt;虚析构&lt;/code&gt;:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-构造函数:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;a. 构造函数&lt;/h2&gt;

&lt;p&gt;从以下汇编代码来看，这个构造函数大概做了两件事：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先调用3个父类的构造函数构造好父类空间.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将3个父类的虚表替换为Sub自身的虚表.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;.text:0000000000008D14 ; __int64 __fastcall Sub::Sub(Sub *__hidden this)
.text:0000000000008D14                 WEAK _ZN3SubC2Ev
.text:0000000000008D14 _ZN3SubC2Ev                             ; CODE XREF: Sub::Sub(void)+Cj
.text:0000000000008D14                                         ; DATA XREF: .got:_ZN3SubC2Ev_ptro
.text:0000000000008D14
.text:0000000000008D14 var_20          = -0x20
.text:0000000000008D14 var_10          = -0x10
.text:0000000000008D14 var_s0          =  0
.text:0000000000008D14
.text:0000000000008D14                 STP             X22, X21, [SP,#-0x10+var_20]!
.text:0000000000008D18                 STP             X20, X19, [SP,#0x20+var_10]
.text:0000000000008D1C                 STP             X29, X30, [SP,#0x20+var_s0]
.text:0000000000008D20                 ADD             X29, SP, #0x20
# ------------------------------------------------- inline SuperA::SuperA() - start ---------------------------------------------
.text:0000000000008D24                 ADRP            X21, #_ZTV6SuperA_ptr@PAGE
.text:0000000000008D28                 LDR             X21, [X21,#_ZTV6SuperA_ptr@PAGEOFF]
.text:0000000000008D2C                 ADRP            X20, #aC@PAGE ; &amp;quot;c++&amp;quot;
.text:0000000000008D30                 ADD             X20, X20, #aC@PAGEOFF ; &amp;quot;c++&amp;quot;
.text:0000000000008D34                 ADRP            X2, #aSuperaSupera@PAGE ; &amp;quot;SuperA::SuperA()&amp;quot;
.text:0000000000008D38                 MOV             X19, X0
.text:0000000000008D3C                 ADD             X8, X21, #0x10    # +0x10是因为要跳过虚表头部的0x8(全0)+0x8(typeinfo ptr)
.text:0000000000008D40                 ADD             X2, X2, #aSuperaSupera@PAGEOFF ; &amp;quot;SuperA::SuperA()&amp;quot;
.text:0000000000008D44                 MOV             W0, #3
.text:0000000000008D48                 MOV             X1, X20
.text:0000000000008D4C                 STR             X8, [X19]    # 1. 在sub obj内部offset:0x00的位置作为SuperA的对象区域
.text:0000000000008D50                 BL              .__android_log_print
# ------------------------------------------------- inline SuperA::SuperA() - end ---------------------------------------------
# ------------------------------------------------- inline SuperB::SuperB() - start ---------------------------------------------
.text:0000000000008D54                 ADRP            X22, #_ZTV6SuperB_ptr@PAGE
.text:0000000000008D58                 LDR             X22, [X22,#_ZTV6SuperB_ptr@PAGEOFF]
.text:0000000000008D5C                 ADD             X8, X22, #0x10
.text:0000000000008D60                 STR             X8, [X19,#0x10]    # 2. 在sub obj内部offset:0x10的位置作为SuperA的对象区域
.text:0000000000008D64                 ADRP            X2, #aSuperbSuperb@PAGE ; &amp;quot;SuperB::SuperB()&amp;quot;
.text:0000000000008D68                 ADD             X2, X2, #aSuperbSuperb@PAGEOFF ; &amp;quot;SuperB::SuperB()&amp;quot;
.text:0000000000008D6C                 MOV             W0, #3
.text:0000000000008D70                 MOV             X1, X20
.text:0000000000008D74                 BL              .__android_log_print
# ------------------------------------------------- inline SuperB::SuperB() - end ---------------------------------------------
# ------------------------------------------------- inline SuperC::SuperC() - start ---------------------------------------------
.text:0000000000008D78                 ADRP            X20, #_ZTV6SuperC_ptr@PAGE
.text:0000000000008D7C                 LDR             X20, [X20,#_ZTV6SuperC_ptr@PAGEOFF]
.text:0000000000008D80                 ADD             X8, X20, #0x10
.text:0000000000008D84                 STR             X8, [X19,#0x20]    # 3. 在sub obj内部offset:0x20的位置作为SuperA的对象区域
.text:0000000000008D88                 ADRP            X1, #aC@PAGE ; &amp;quot;c++&amp;quot;
.text:0000000000008D8C                 ADRP            X2, #aSupercSuperc@PAGE ; &amp;quot;SuperC::SuperC()&amp;quot;
.text:0000000000008D90                 ADD             X1, X1, #aC@PAGEOFF ; &amp;quot;c++&amp;quot;
.text:0000000000008D94                 ADD             X2, X2, #aSupercSuperc@PAGEOFF ; &amp;quot;SuperC::SuperC()&amp;quot;
.text:0000000000008D98                 MOV             W0, #3
.text:0000000000008D9C                 BL              .__android_log_print
# ------------------------------------------------- inline SuperC::SuperC() - end ---------------------------------------------
.text:0000000000008DA0                 ADRP            X8, #_ZTV3Sub_ptr@PAGE
.text:0000000000008DA4                 LDR             X8, [X8,#_ZTV3Sub_ptr@PAGEOFF]
.text:0000000000008DA8                 ADD             X9, X8, #0x10    # 1. 取出Sub的第1块虚表， 用于覆盖SuperA.
.text:0000000000008DAC                 ADD             X10, X8, #0x60    # 2. 取出Sub的第2块虚表， 用于覆盖SuperB.
.text:0000000000008DB0                 ADD             X8, X8, #0xA0    # 3. 取出Sub的第3块虚表， 用于覆盖SuperC.
.text:0000000000008DB4                 STR             X9, [X19]    # 1. 用Sub的第1块虚表, 覆盖掉SuperA的虚表.
.text:0000000000008DB8                 STR             X10, [X19,#0x10]   # 2. 用Sub的第2块虚表, 覆盖掉SuperB的虚表.
.text:0000000000008DBC                 STR             X8, [X19,#0x20]    # 3. 用Sub的第3块虚表, 覆盖掉SuperC的虚表.
.text:0000000000008DC0                 ADRP            X1, #aC@PAGE ; &amp;quot;c++&amp;quot;
.text:0000000000008DC4                 ADRP            X2, #aSubSub@PAGE ; &amp;quot;Sub::Sub()&amp;quot;
.text:0000000000008DC8                 ADD             X1, X1, #aC@PAGEOFF ; &amp;quot;c++&amp;quot;
.text:0000000000008DCC                 ADD             X2, X2, #aSubSub@PAGEOFF ; &amp;quot;Sub::Sub()&amp;quot;
.text:0000000000008DD0                 MOV             W0, #3
.text:0000000000008DD4                 BL              .__android_log_print
.text:0000000000008DD8                 LDP             X29, X30, [SP,#0x20+var_s0]
.text:0000000000008DDC                 LDP             X20, X19, [SP,#0x20+var_10]
.text:0000000000008DE0                 LDP             X22, X21, [SP+0x20+var_20],#0x30
.text:0000000000008DE4                 RET
.text:0000000000008DE4 ; End of function Sub::Sub(void)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上三个父类的大小之所以为0x10，是因为:0x8(VT) + 0x4(this-&amp;gt;value_*) + 0x4(align), 最后class Sub的内存布局为：&lt;/p&gt;

&lt;h2 id=&#34;b-内存布局:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;b.内存布局&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;2.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;根据以上图片得出，内存的分布为先父类后子类。以上的&lt;code&gt;Sub::value_sub&lt;/code&gt;被分配到了最尾部.&lt;/p&gt;

&lt;h2 id=&#34;c-虚表:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;c.虚表&lt;/h2&gt;

&lt;p&gt;以上代码中共有4个类，但一共只有三个虚表。这是因为子类Sub的虚表与首个父类SuperA进行了合并。以下是三个虚表的分布和指向情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ============================== [off: 0x00] SuperA &amp;amp; Sub =================================
.data.rel.ro:000000000003EF40 off_3EF40       DCQ _ZN3SubD2Ev         ; Sub::~Sub()    # 虚析构函数1
.data.rel.ro:000000000003EF48                 DCQ _ZN3SubD0Ev         ; Sub::~Sub()    # 虚析构函数2 (该析构比`析构函数1`多了释放内存的操作，专供delete释放动态new出来的对象)
.data.rel.ro:000000000003EF50                 DCQ _ZN3Sub4fun1Ei      ; Sub::fun1(int)    # 这里指向Sub::fun1(int)
.data.rel.ro:000000000003EF58                 DCQ _ZN3Sub4fun2Ei      ; Sub::fun2(int)    # 这里指向Sub::fun2(int)
.data.rel.ro:000000000003EF60                 DCQ _ZN6SuperA5testAEi  ; SuperA::testA(int)    # 这里指向SuperA::testA(int)
.data.rel.ro:000000000003EF68                 DCQ _ZN3Sub4fun3Ei      ; Sub::fun3(int)    # 这里指向Sub::fun3(int)
.data.rel.ro:000000000003EF70                 DCQ _ZN3Sub4fun4Ei      ; Sub::fun4(int)    # 这里指向Sub::fun4(int)
.data.rel.ro:000000000003EF78                 DCQ _ZN3Sub6testC3Ei    ; Sub::testC3(int)    # 这里指向Sub::testC3(int)

# ============================== [off: 0x10] SuperB =================================
.data.rel.ro:000000000003EF90 off_3EF90       DCQ _ZThn16_N3SubD1Ev   ; `non-virtual thunk to&#39;Sub::~Sub()    # 这里指向了虚析构函数1: Sub::~Sub(), 因为声明了虚析构
.data.rel.ro:000000000003EF98                 DCQ _ZThn16_N3SubD0Ev   ; `non-virtual thunk to&#39;Sub::~Sub()    # 这里指向了虚析构函数1: Sub::~Sub(), 因为声明了虚析构
.data.rel.ro:000000000003EFA0                 DCQ _ZThn16_N3Sub4fun1Ei ; `non-virtual thunk to&#39;Sub::fun1(int)    # 这里指向了Sub::fun1(), 因为SuperB::fun1已被Sub:fun1覆盖
.data.rel.ro:000000000003EFA8                 DCQ _ZThn16_N3Sub4fun2Ei ; `non-virtual thunk to&#39;Sub::fun2(int)     # 这里指向了Sub::fun2(), 因为SuperB::fun2已被Sub:fun2覆盖
.data.rel.ro:000000000003EFB0                 DCQ _ZN6SuperB6testB1Ei ; SuperB::testB1(int)     # 这里指向了SuperB::testB1(), 未被覆盖
.data.rel.ro:000000000003EFB8                 DCQ _ZN6SuperB6testB2Ei ; SuperB::testB2(int)    # 这里指向了SuperB::testB2(), 未被覆盖

# ============================== [off: 0x20] SuperC =================================
.data.rel.ro:000000000003EFD0 off_3EFD0       DCQ _ZThn32_N3SubD1Ev   ; `non-virtual thunk to&#39;Sub::~Sub()    # 这里指向了虚析构函数1: Sub::~Sub(), 同SuperB
.data.rel.ro:000000000003EFD8                 DCQ _ZThn32_N3SubD0Ev   ; `non-virtual thunk to&#39;Sub::~Sub()    # 这里指向了虚析构函数1: Sub::~Sub(), 同SuperB
.data.rel.ro:000000000003EFE0                 DCQ _ZThn32_N3Sub4fun1Ei ; `non-virtual thunk to&#39;Sub::fun1(int)    # 这里指向了Sub::fun1(), 因为SuperC::fun1已被Sub:fun1覆盖
.data.rel.ro:000000000003EFE8                 DCQ _ZThn32_N3Sub4fun2Ei ; `non-virtual thunk to&#39;Sub::fun2(int)     # 这里指向了Sub::fun2(), 因为SuperC::fun2已被Sub:fun2覆盖
.data.rel.ro:000000000003EFF0                 DCQ _ZN6SuperC6testC1Ei ; SuperC::testC1(int)     # 这里指向了SuperC::testC1(), 未被覆盖
.data.rel.ro:000000000003EFF8                 DCQ _ZN6SuperC6testC2Ei ; SuperC::testC2(int)    # 这里指向了SuperC::testC2(), 未被覆盖
.data.rel.ro:000000000003F000                 DCQ _ZThn32_N3Sub6testC3Ei ; `non-virtual thunk to&#39;Sub::testC3(int)    # 这里指向了Sub::testC3(), 因为SuperC::testC3已被Sub::testC3覆盖实现
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上虚表中，类型为&lt;code&gt;non-virtual thunk&lt;/code&gt;的为中转函数(在实际生产环境中IDA不一定能直接识别出&lt;code&gt;non-virtual thunk&lt;/code&gt;)，表明该位置的函数已被覆盖，通过该中转函数将调用跳转到覆盖后的新函数中，举例：&lt;/p&gt;

&lt;p&gt;以上&lt;code&gt;SuperB::fun2&lt;/code&gt;与&lt;code&gt;SuperC::fun2&lt;/code&gt;均被&lt;code&gt;Sub::fun2&lt;/code&gt;覆盖， 所以该虚表项直接被替换为中转函数地址，将调用转到&lt;code&gt;Sub::fun2()&lt;/code&gt;中以实现多态。该中转函数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.text:00000000000097E4 ; __int64 __fastcall `non-virtual thunk to&#39;Sub::fun2(Sub *__hidden this, int)
.text:00000000000097E4                 WEAK _ZThn16_N3Sub4fun2Ei
.text:00000000000097E4 _ZThn16_N3Sub4fun2Ei                    ; DATA XREF: .data.rel.ro:000000000003EFA8o
.text:00000000000097E4
.text:00000000000097E4 var_C           = -0xC
.text:00000000000097E4 var_8           = -8
.text:00000000000097E4
.text:00000000000097E4 ; FUNCTION CHUNK AT .plt:0000000000008840 SIZE 00000010 BYTES
.text:00000000000097E4
.text:00000000000097E4                 SUB             SP, SP, #0x10
.text:00000000000097E8                 STR             X0, [SP,#0x10+var_8]
.text:00000000000097EC                 STR             W1, [SP,#0x10+var_C]
.text:00000000000097F0                 LDR             X0, [SP,#0x10+var_8]
.text:00000000000097F4                 SUBS            X0, X0, #0x10 ; this    # 将this减去0x10后指针回到Sub头(因为此函数被调用前，this会被加上0x10)
.text:00000000000097F8                 ADD             SP, SP, #0x10
.text:00000000000097FC                 B               ._ZN3Sub4fun2Ei ; Sub::fun2(int)  # 转到Sub::fun2()
.text:00000000000097FC ; End of function `non-virtual thunk to&#39;Sub::fun2(int)
.text:00000000000097FC
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上中转函数中的this-0x*也可作为识别&lt;code&gt;non-virtual thunk&lt;/code&gt;的一种特征.&lt;/p&gt;

&lt;h2 id=&#34;d-虚函数调用:d95adee7c84ca4f29ce79a26699e6aed&#34;&gt;d.虚函数调用&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;a). 首先分析，调用的目标为：&lt;code&gt;父类&lt;/code&gt;中未被&lt;code&gt;子类&lt;/code&gt;覆盖的虚函数，如： 调用&lt;code&gt;sub-&amp;gt;testB1()&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C++代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub-&amp;gt;testB1((int)env-&amp;gt;GetVersion());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应汇编代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.text:0000000000008B74                 LDR             X8, [X21,#0x10]!   # 1. X21为this, this+0x10定位到SuperB的头部
.text:0000000000008B78                 LDR             X9, [X19]
.text:0000000000008B7C                 LDR             X22, [X8,#0x20]    # 2. X8为SuperB头部的虚表(构造时已被替换为Sub的)，[X8+0x20]即可得到SuperB::testB1的地址(对照上节`c.虚表`中的虚表内容即可证明)。
.text:0000000000008B80                 LDR             X8, [X9,#0x20]
.text:0000000000008B84                 MOV             X0, X19
.text:0000000000008B88                 BLR             X8    # 调用env-&amp;gt;GetVersion()
.text:0000000000008B8C                 MOV             W1, W0
.text:0000000000008B90                 MOV             X0, X21
.text:0000000000008B94                 BLR             X22    # 3.调用SuperB::testB1()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;调用没有被&lt;code&gt;子类&lt;/code&gt;覆盖的方法时，依旧会依赖&lt;code&gt;父类&lt;/code&gt;的&lt;code&gt;虚表&lt;/code&gt;(本例中使用SuperB的虚表进行调用).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b). 接下来分析，调用的目标为：&lt;code&gt;父类&lt;/code&gt;中已被&lt;code&gt;子类&lt;/code&gt;覆盖的虚函数，如：调用&lt;code&gt;sub-&amp;gt;fun2()&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C++代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub-&amp;gt;fun2((int)env-&amp;gt;GetVersion());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应汇编代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.text:0000000000008AE0                 LDR             X8, [X20]    # 1. X20为this, 这里直接取出Sub/SuperA的虚表(因为Sub与SuperA的虚表混合为一体，并且该虚表已被Sub替换)
.text:0000000000008AE4                 LDR             X9, [X19]
.text:0000000000008AE8                 LDR             X21, [X8,#0x18]    # 2. 取出虚表中index为3的项， 里面存放这Sub::fun2的指针(对照上节`c.虚表`中的虚表内容即可证明)。
.text:0000000000008AEC                 LDR             X8, [X9,#0x20]
.text:0000000000008AF0                 MOV             X0, X19
.text:0000000000008AF4                 BLR             X8  # 调用env-&amp;gt;GetVersion()
.text:0000000000008AF8                 MOV             W1, W0
.text:0000000000008AFC                 MOV             X0, X20
.text:0000000000008B00                 BLR             X21    # 3. 调用Sub::fun2()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;调用被&lt;code&gt;子类&lt;/code&gt;覆盖的方法时，会直接使用&lt;code&gt;子类&lt;/code&gt;的&lt;code&gt;虚表&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android服务注册及获取</title>
      <link>https://pkiller.com/android/Android%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%8A%E8%8E%B7%E5%8F%96/</link>
      <pubDate>Sun, 14 May 2017 18:32:05 +0800</pubDate>
      
      <guid>https://pkiller.com/android/Android%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%8A%E8%8E%B7%E5%8F%96/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;本文以Android 5.1为例展开，在7.0上细节会略有差异，但基本一致：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;service大致分为两种:397449707725e38003a9ceae41cf8909&#34;&gt;Service大致分为两种&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1. 系统服务SystemService&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;// 以下展示的框架为标准的Android SystemService的调用结构。如：Context.LOCATION_SERVICE.
[services.jar部分]&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;服务提供方通过ServiceManager.addService()注册服务&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;服务调用方通过ServiceManager.getService()获取服务，为IBinder类型. (通常供framework.jar使用，framework.jar内部会再包装Wrapper类，最后供上层APP使用.)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[framework.jar部分]&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用ContextImpl.registerService() (在7.0上为SystemServiceRegistry), 将通过ServiceManager.getService()的到的IBinder对象注册到framework中.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在APP中使用context.getSystemService(LOCATION_SERVICE)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2. 普通APP的Binder服务&lt;/strong&gt;
     服务提供方在内部最终通过什么注册服务?  (TODO: 分析如应用中的服务是如何注册的)
     服务调用放通过bindService获得服务，为IBinder类型&lt;/p&gt;

&lt;p&gt;以上两种方法对于IBinder都一样，使用asInterface将IBinder转为可方便调用的Client端接口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public static IPowerManager asInterface(IBinder arg2) {
        IPowerManager v1 = null;
        if(arg2 == null) {
            return v1;
        }

        IInterface v0 = arg2.queryLocalInterface(&amp;quot;android.os.IPowerManager&amp;quot;);
        if(v0 != null &amp;amp;&amp;amp; ((v0 instanceof IPowerManager))) {
            return ((IPowerManager)v0);  // 如果该Service在本进程内，则直接返回。
        }

        return new Proxy(arg2);  // Service不在本进程内，使用Proxy进行代理访问(内部通过mRemote.transact()访问远端服务)。
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1个标准android-systemservice的完整实现:397449707725e38003a9ceae41cf8909&#34;&gt;1个标准Android SystemService的完整实现&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;首先在services.jar中添加服务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在service.jar可以通过调用SystemService.publishBinderService()或ServiceManager.addService将1个Service加入Binder队列.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SystemManager.addService(LOCATION_SERVICE, new LocationManagerService(context));
// or
SystemService.publishBinderService(POWER_SERVICE, new BinderService(this, null));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;最后在framework中使用ContextImpl.registerService()将包装Binder后的Wrapper对象加入队列，之后便可以在APP开发中直接使用context.getSystemService(XXXX_SERVICE)获取Manager(Wrapper)进行服务操作:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// xref: /frameworks/base/core/java/android/app/ContextImpl.java
 static {
      // 将对应Service的Manager(Wrapper)加入管理器中， 以后便可以直接在APP开发中使用context.getSystemService(XXXX_SERVICE)来获取指定服务的Manager(Wrapper).
    /////////////////////////////////////// LOCATION_SERVICE //////////////////////////////////////
    registerService(LOCATION_SERVICE, new ServiceFetcher() {
            public Object createService(ContextImpl ctx) {
                IBinder b = ServiceManager.getService(LOCATION_SERVICE);
                return new LocationManager(ctx, ILocationManager.Stub.asInterface(b)); 
            }});
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;其它:397449707725e38003a9ceae41cf8909&#34;&gt;其它&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;addService / getService大致实现&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// pos: framework.jar
package android.os;
public final class ServiceManager {
    // ...

    public static void addService(String arg3, IBinder arg4) {
        try {
            ServiceManager.getIServiceManager().addService(arg3, arg4, false);
        }
        catch(RemoteException v0) {
            Log.e(&amp;quot;ServiceManager&amp;quot;, &amp;quot;error in addService&amp;quot;, ((Throwable)v0));
        }
    }

    public static IBinder getService(String arg5) {
        IBinder v4 = null;
        try {
            Object v1 = ServiceManager.sCache.get(arg5);
            if(v1 != null) {
                return ((IBinder)v1);
            }

            return ServiceManager.getIServiceManager().getService(arg5);
        }
        catch(RemoteException v0) {
            Log.e(&amp;quot;ServiceManager&amp;quot;, &amp;quot;error in getService&amp;quot;, ((Throwable)v0));
            return v4;
        }
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;publishBinderService的实现&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// pos: services.jar
package com.android.server;
public abstract class SystemService {
    // ...
    protected final void publishBinderService(String arg1, IBinder arg2, boolean arg3) {
        ServiceManager.addService(arg1, arg2, arg3);  // 最终会调入framework.jar中的android.os.ServiceManager
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Android进程级别和oom_adj对应关系</title>
      <link>https://pkiller.com/android/Android%20%E8%BF%9B%E7%A8%8B%E7%BA%A7%E5%88%AB%20%E5%92%8C%20oom_adj%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Sun, 26 Feb 2017 12:56:34 +0800</pubDate>
      
      <guid>https://pkiller.com/android/Android%20%E8%BF%9B%E7%A8%8B%E7%BA%A7%E5%88%AB%20%E5%92%8C%20oom_adj%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/</guid>
      <description>

&lt;p&gt;oom_adj 数值越小证明优先级越高, 被干掉的时间越晚. 如果大于 8 一般就是属于 backgroud 随时可能被干掉. -100为system进程的值, 表示绝不会被干掉.&lt;/p&gt;

&lt;h3 id=&#34;oom-adj-0:6479aa3cb737dc69cbfb28a6c158a468&#34;&gt;[oom_adj=0]&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;前台进程 (Active Process)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前台进程包括:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.活动 正在前台接收用户输入 
2.活动、服务与广播接收器正在执行一个onReceive事件的处理函数
3.服务正在运行 onStart、onCreate或onDestroy事件处理函数.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;已启动服务的进程(Started Service Process)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这类进程包含一个已启动的服务. 服务并不直接与用户输入交互,因此服务的优先级低于可见活动的优先级,但是,已启动服务的进程任被认为是前台进程,只有在活动以及可见活动需要资源时,已启动服务的进程才会被杀死.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;oom-adj-1:6479aa3cb737dc69cbfb28a6c158a468&#34;&gt;[oom_adj=1]&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;可见进程 (Visible Process)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;活动是可见的,但并不在前台,或者不响应用户的输入.例如,活动被非全屏或者透明的活动所遮挡.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;oom-adj-2:6479aa3cb737dc69cbfb28a6c158a468&#34;&gt;[oom_adj=2]&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;后台进程 (Backgroud Process)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这类进程不包含任何可见的活动与启动的服务.通常大量后台进程存在时,系统会采用（last-seen-first-kill）后见先杀的方式,释放资源为前台进程使用.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;oom-adj-4:6479aa3cb737dc69cbfb28a6c158a468&#34;&gt;[oom_adj=4]&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;主界面 (home process)&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;oom-adj-7:6479aa3cb737dc69cbfb28a6c158a468&#34;&gt;[oom_adj=7]&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;隐藏进程 (hidden process)&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;oom-adj-14:6479aa3cb737dc69cbfb28a6c158a468&#34;&gt;[oom_adj=14]&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;内容提供者 (content provider)&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;oom-adj-15:6479aa3cb737dc69cbfb28a6c158a468&#34;&gt;[oom_adj=15]&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;空进程 (Empty process)&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ELF的DUMP及修复思路</title>
      <link>https://pkiller.com/android/ELF%E7%9A%84dump%E5%8F%8A%E4%BF%AE%E5%A4%8D%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Tue, 12 Jul 2016 11:02:04 +0800</pubDate>
      
      <guid>https://pkiller.com/android/ELF%E7%9A%84dump%E5%8F%8A%E4%BF%AE%E5%A4%8D%E6%80%9D%E8%B7%AF/</guid>
      <description>

&lt;p&gt;加壳后ELF的&lt;code&gt;section&lt;/code&gt;基本是被抹掉或是被写垃圾数据的, 但&lt;code&gt;section&lt;/code&gt;对于静态分析来讲又非常重要, 所以DUMP后有必要重建&lt;code&gt;section&lt;/code&gt;让静态分析的体验变得更好.&lt;/p&gt;

&lt;h1 id=&#34;elf的内存分布:792db8d7eccee293d26f4568a278e763&#34;&gt;ELF的内存分布&lt;/h1&gt;

&lt;p&gt;因为&lt;code&gt;section&lt;/code&gt;的部分项目只能通过编译器的一些特定规律和残留的信息来恢复,不可能百分百重建和还原. 所以必须先对编译器规划的内存布局有一个清晰的了解. 以下是一个32bit的ELF(.so)文件中在内存中的常见分布情况:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;{ [0x0h]elf(.so)
  { [0x0h]PT_LOAD(0)
    { [0x0h]ehdr
    } [0x33h]ehdr

    { [0x34h]PT_PHDR / phdr
    } [0x133h]PT_PHDR / phdr

    { [0x134h].interp / PT_INERP
    } [0x146h].interp / PT_INERP

    /* gap size: 1h  */
    { [0x148h].dynsym / DT_SYMTAB
    } [0x607h].dynsym / DT_SYMTAB

    { [0x608h].dynstr / DT_STRTAB
    } [0xbdah].dynstr / DT_STRTAB

    /* gap size: 1h  */
    { [0xbdch].hash / DT_HASH
    } [0xe1fh].hash / DT_HASH

    { [0xe20h].rel.dyn / DT_REL
    } [0xe67h].rel.dyn / DT_REL

    { [0xe68h].rel.plt / DT_JMPREL
    } [0xf1fh].rel.plt / DT_JMPREL

    { [0xf20h].plt
    } [0x1047h].plt

    { [0x1048h].text
    } [0x2b23h].text

    { [0x2b24h].ARM.extab
    } [0x2b8fh].ARM.extab

    { [0x2b90h].ARM.exidx
    } [0x2cbfh].ARM.exidx

    { [0x2cc0h].rodata
    } [0x2d2fh].rodata
  } [0x2d2fh]PT_LOAD(0)

  /* gap size: 113ch  */
  { [0x3e6ch]PT_LOAD(1)
    { [0x3e6ch]PT_UNK_70000001h
      { [0x3e6ch].fini_array / DT_FINI_ARRAY
      } [0x3e73h].fini_array / DT_FINI_ARRAY

      { [0x3e74h].init_array / DT_INIT_ARRAY
      } [0x3e77h].init_array / DT_INIT_ARRAY

      { [0x3e78h].dynamic / PT_DYNAMIC
      } [0x3f77h].dynamic / PT_DYNAMIC

      { [0x3f78h].got
        { [0x3f98h]DT_PLTGOT
        } [0x3fffh]DT_PLTGOT
      } [0x3fffh].got
    } [0x3fffh]PT_UNK_70000001h

    { [0x4000h].data
    } [0x4003h].data
  } [0x4003h]PT_LOAD(1)
} [0x4003h]elf(.so)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;案例分析:792db8d7eccee293d26f4568a278e763&#34;&gt;案例分析&lt;/h1&gt;

&lt;p&gt;这里用某厂商加固中携带的so文件来试验:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;section只有一个有效项&lt;code&gt;.strtab&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;2.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;加载so后DUMP&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;dump后section已经丢失:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;3.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;用IDA打开后查看效果,首先依赖库信息丢失:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;4.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其次Sections信息不全:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;5.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;该so外壳通过DT_INIT还原代码.&lt;/p&gt;

&lt;h1 id=&#34;section重建:792db8d7eccee293d26f4568a278e763&#34;&gt;SECTION重建&lt;/h1&gt;

&lt;p&gt;在重建时尽量使用soinfo中的信息, 因为ELF中的关键信息可能被篡改和抹去.&lt;/p&gt;

&lt;h2 id=&#34;通过pt-dynamic重建:792db8d7eccee293d26f4568a278e763&#34;&gt;通过PT_DYNAMIC重建&lt;/h2&gt;

&lt;p&gt;因为部分section在&lt;code&gt;PT_DYNAMIC&lt;/code&gt;中存在副本,所以依赖&lt;code&gt;PT_DYNAMIC&lt;/code&gt;很容易恢复出对应项.&lt;/p&gt;

&lt;p&gt;从上面的内存分布图可以找到很多存在于&lt;code&gt;PT_DYNAMIC&lt;/code&gt;中的section项, 有如下:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;.hash / DT_HASH&lt;/p&gt;

&lt;p&gt;.rel.dyn / DT_REL&lt;/p&gt;

&lt;p&gt;.interp / PT_INERP&lt;/p&gt;

&lt;p&gt;.dynsym / DT_SYMTAB&lt;/p&gt;

&lt;p&gt;.dynstr / DT_STRTAB&lt;/p&gt;

&lt;p&gt;.rel.plt / DT_JMPREL&lt;/p&gt;

&lt;p&gt;.dynamic / PT_DYNAMIC&lt;/p&gt;

&lt;p&gt;.fini_array / DT_FINI_ARRAY&lt;/p&gt;

&lt;p&gt;.init_array / DT_INIT_ARRAY&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上这些section header都可以直接照搬&lt;code&gt;PT_DYNAMIC&lt;/code&gt;中的offset来修复,关于size可以参照以下:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;section name&lt;/th&gt;
&lt;th&gt;dynamic type&lt;/th&gt;
&lt;th&gt;size&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;.hash&lt;/td&gt;
&lt;td&gt;DT_HASH&lt;/td&gt;
&lt;td&gt;(nbucket+nchain)*4+8&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;.rel.dyn&lt;/td&gt;
&lt;td&gt;DT_REL&lt;/td&gt;
&lt;td&gt;DT_RELSZ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;.rel.plt&lt;/td&gt;
&lt;td&gt;DT_JMPREL&lt;/td&gt;
&lt;td&gt;DT_PLTSZ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;.interp&lt;/td&gt;
&lt;td&gt;PT_INERP&lt;/td&gt;
&lt;td&gt;strlen(ptr)+1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;.dynsym&lt;/td&gt;
&lt;td&gt;DT_SYMTAB&lt;/td&gt;
&lt;td&gt;nchain*sizeof(Elf32_Sym)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;.dynstr&lt;/td&gt;
&lt;td&gt;DT_STRTAB&lt;/td&gt;
&lt;td&gt;DT_STRSZ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;.dynamic&lt;/td&gt;
&lt;td&gt;PT_DYNAMIC&lt;/td&gt;
&lt;td&gt;PT_DYNAMIC-&amp;gt;p_filesz&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;.fini_array&lt;/td&gt;
&lt;td&gt;DT_FINI_ARRAY&lt;/td&gt;
&lt;td&gt;DT_FINI_ARRAYSZ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;.init_array&lt;/td&gt;
&lt;td&gt;DT_INIT_ARRAY&lt;/td&gt;
&lt;td&gt;DT_INIT_ARRAYSZ&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;其他要点:792db8d7eccee293d26f4568a278e763&#34;&gt;其他要点&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;DT_INIT_ARRAY、DT_FINI_ARRAY、DT_INIT、DT_FINI&lt;/strong&gt;
以上四项的函数offset在load以后被填充为了base+offset,所以dump以后要减去base恢复其offset.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;通过固有位置重建:792db8d7eccee293d26f4568a278e763&#34;&gt;通过固有位置重建&lt;/h2&gt;

&lt;p&gt;通过编译器固有的上下文对section进行恢复,这种方式恢复出来的信息不一定完全准确,但不失为一种有效的重建手段.&lt;/p&gt;

&lt;h3 id=&#34;plt的重建:792db8d7eccee293d26f4568a278e763&#34;&gt;.plt的重建&lt;/h3&gt;

&lt;h4 id=&#34;plt位置:792db8d7eccee293d26f4568a278e763&#34;&gt;.plt位置&lt;/h4&gt;

&lt;p&gt;根据上面的内存布局图得出.plt通常紧跟.rel.plt, 并且之间没有空隙.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    { [0xe68h].rel.plt / DT_JMPREL
    } [0xf1fh].rel.plt / DT_JMPREL

    { [0xf20h].plt
    } [0x1047h].plt
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;plt大小:792db8d7eccee293d26f4568a278e763&#34;&gt;.plt大小&lt;/h4&gt;

&lt;p&gt;.plt头部会有0x14个固定作用的数据(0x10指令+0x4偏移)&lt;/p&gt;

&lt;p&gt;然后.plt之后存放了与.rel.plt中Elf32_Rel数量相同的代码块,每个代码块0x0Cbyte(3条arm指令).代码块负责间接调用got项中的import函数.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;6.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;got的重建:792db8d7eccee293d26f4568a278e763&#34;&gt;.got的重建&lt;/h3&gt;

&lt;h4 id=&#34;got位置:792db8d7eccee293d26f4568a278e763&#34;&gt;.got位置&lt;/h4&gt;

&lt;p&gt;.got项可以通过DT_REL与DT_JMPREL中的Elf32_Rel::r_offset来依次遍历得到, 通过其中的最小和最大地址来确定.got的位置和大小.&lt;/p&gt;

&lt;p&gt;但是实际测试时针对不同的文件得到的.got位置总是存在一定误差. 如下两个例子:&lt;/p&gt;

&lt;p&gt;第一个文件,以第一个有效项为.got的开始位置:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;7.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第二个文件,却以R_ARM_RELATIVE为开始位置,没有掌握规律:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;8.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;按照以上任一的方法来确定.got,都无法兼容所有情况. 所以针对.got的位置确定, 更换一种思路: 使用前后关系来确定.got区域:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;回溯上面的ELF内存分布图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;      { [0x3e78h].dynamic / PT_DYNAMIC
      } [0x3f77h].dynamic / PT_DYNAMIC

      { [0x3f78h].got
        { [0x3f98h]DT_PLTGOT
        } [0x3fffh]DT_PLTGOT
      } [0x3fffh].got
    } [0x3fffh]PT_UNK_70000001h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可得到关系: .got 起始于.dynamic, 并终于PT_UNK_700000001h. 用此方法对脱壳的so进行验证: .got确定成功.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;9.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;got大小:792db8d7eccee293d26f4568a278e763&#34;&gt;.got大小&lt;/h4&gt;

&lt;p&gt;跟&lt;strong&gt;.got位置&lt;/strong&gt;的计算方法一样,也是通过遍历Elf32_Rel::r_offset来得到最大地址,但是由于&lt;strong&gt;.got位置&lt;/strong&gt;的确定存在误差,所以&lt;strong&gt;.got大小&lt;/strong&gt;也无法保证准确,只能是侍机手工去调整.&lt;/p&gt;

&lt;h3 id=&#34;data的重建:792db8d7eccee293d26f4568a278e763&#34;&gt;.data的重建&lt;/h3&gt;

&lt;h4 id=&#34;data位置:792db8d7eccee293d26f4568a278e763&#34;&gt;.data位置&lt;/h4&gt;

&lt;p&gt;根据内存布局图推出.data通常紧跟.got的尾部,也可以认为是紧跟type==0x70000001的尾部.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;      } [0x3fffh].got
    } [0x3fffh]PT_UNK_70000001h

    { [0x4000h].data
    } [0x4003h].data
  } [0x4003h]PT_LOAD(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;10.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;data大小:792db8d7eccee293d26f4568a278e763&#34;&gt;.data大小&lt;/h4&gt;

&lt;p&gt;内存布局中PT_LOAD(1)的结尾即为.data的结尾,所以根据此可以确定.data的大小.&lt;/p&gt;

&lt;h3 id=&#34;rodata的重建:792db8d7eccee293d26f4568a278e763&#34;&gt;.rodata的重建&lt;/h3&gt;

&lt;h4 id=&#34;rodata的位置:792db8d7eccee293d26f4568a278e763&#34;&gt;.rodata的位置&lt;/h4&gt;

&lt;p&gt;根据内存布局图推出.rodata存在于PT_LOAD(0)尾部, 紧跟.ARM.exidx.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    { [0x2b90h].ARM.exidx
    } [0x2cbfh].ARM.exidx

    { [0x2cc0h].rodata
    } [0x2d2fh].rodata
  } [0x2d2fh]PT_LOAD(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;11.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;rodata的长度:792db8d7eccee293d26f4568a278e763&#34;&gt;.rodata的长度&lt;/h4&gt;

&lt;p&gt;长度占据了.ARM.exidx之后的全部空间&lt;/p&gt;

&lt;h3 id=&#34;总结:792db8d7eccee293d26f4568a278e763&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;根据以上的思路也可以对其他的section进行恢复.&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&#34;dt-needed的修复:792db8d7eccee293d26f4568a278e763&#34;&gt;DT_NEEDED的修复&lt;/h1&gt;

&lt;p&gt;PT_DYNAMIC下每一项type==DT_NEEDED的Elf32_Dyn::d_val存放了strtab的index, index指向的字符串为外部library(.so)文件名. 被load后Elf32_Dyn::d_val会被赋值为对应的soinfo指针.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct soinfo {
 public:
  char name[SOINFO_NAME_LEN];
  /*...*/
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修复方法是通过soinfo::name从strtab中搜索字符串的index, 最后将此index重新赋值Elf32_Dyn::d_val来完成DT_NEEDED的修复.&lt;/p&gt;

&lt;h1 id=&#34;最终效果:792db8d7eccee293d26f4568a278e763&#34;&gt;最终效果&lt;/h1&gt;

&lt;p&gt;根据以上思路写一个简单的dump+repair的辅助脱壳工具:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;12.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最终修复完成的效果:
DT_NEEDED&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;13.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;.plt&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;14.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;.got&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;15.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;全部section&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;16.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;全文完~&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&#34;参考资料:792db8d7eccee293d26f4568a278e763&#34;&gt;参考资料&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;《Executable and Linkable Format (ELF)》&lt;/strong&gt;
 &lt;strong&gt;AOSP/bionic/linker&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ELF32 (Android ARM)</title>
      <link>https://pkiller.com/android/ELF32%20%28Android%20ARM%29/</link>
      <pubDate>Sat, 18 Jun 2016 08:36:15 +0800</pubDate>
      
      <guid>https://pkiller.com/android/ELF32%20%28Android%20ARM%29/</guid>
      <description>

&lt;p&gt;首先勘误： 下图中 用STB_WEAK 来表示导出函数是错误的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;1.png&#34; alt=&#34;img&#34; title=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-rel-dyn-dt-rel-和-rel-plt-dt-jmprel-的区别:d797541984d2426be471f97863bea3b7&#34;&gt;1. &lt;code&gt;.rel.dyn(DT_REL)&lt;/code&gt; 和 &lt;code&gt;.rel.plt(DT_JMPREL)&lt;/code&gt; 的区别.&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;在任意位置 使用静态方式 调用导入函数(API)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;引用项会出现在.rel.plt(DT_JMPREL)中, TYPE为R_ARM_JUMP_SLOT&lt;/p&gt;

&lt;p&gt;例子:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      exit (0);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;在函数内 使用指针方式 调用导入函数(API)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;引用项会出现在.rel.dyn(DT_REL)中, TYPE为R_ARM_GLOB_DAT&lt;/p&gt;

&lt;p&gt;例子:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; void fun(){

    typedef void *(*my_exit )(int);

    my_exit exit_ptr = (my_exit )exit;

    exit_ptr(0);

 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;在全局 引用导入函数(API)指针&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;引用项会分别在.rel.dyn(DT_REL)和.rel.plt(DT_JMPREL)中各加入一条:&lt;/p&gt;

&lt;p&gt;在.rel.dyn(DT_REL)中加入TYPE为R_ARM_ABS32.&lt;/p&gt;

&lt;p&gt;在.rel.plt(DT_JMPREL)中加入TYPE为R_ARM_JUMP_SLOT.&lt;/p&gt;

&lt;p&gt;例子:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      void *g_exit = (void*)exit;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-got-概念-global-offset-table:d797541984d2426be471f97863bea3b7&#34;&gt;2. GOT 概念(GLOBAL OFFSET TABLE)&lt;/h2&gt;

&lt;p&gt;module的GOT表被加载时, 会由linker填充该module导入函数的addr. 之后该module中的代码通过GOT中被填充好的地址值来间接调用导入函数.&lt;/p&gt;

&lt;p&gt;GOT表无需太关注, 因为GOT中的每一项Elf32_Addr. 都有DT_REL和DT_JMPREL中Elf32_Rel::r_offset对其的指向,被所有Elf32_Rel::r_offset指向形成的这一片连续Elf32_Addr区域就被称为&amp;rdquo;GOT表&amp;rdquo;, 理论上讲所有的Elf32_Rel::r_offset也可以指向不连续的区域(前提是linker不再按照连续地址方式处理. 目前linker中对got表的处理使用了地址连续的方式.).这样在对抗和逆向中就多了一条路径: 通过Elf32_Rel::r_offset来找到对应got项.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DT_PLTGOT与&amp;rdquo;.got&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;dynamic的DT_PLTGOT处于section的&amp;rdquo;.got&amp;rdquo;范围之中:
        &amp;ldquo;.got&amp;rdquo; :[item,item,&amp;hellip;,DT_PLTGOT[item,item,&amp;hellip;]]&lt;/p&gt;

&lt;h2 id=&#34;3-hook-导入-导出函数:d797541984d2426be471f97863bea3b7&#34;&gt;3. HOOK 导入/导出函数.&lt;/h2&gt;

&lt;p&gt;导入函数信息存储于Elf32_Rel结构中, 该结构位于: (program_table::p_type == PT_DYNAMIC)的项下的Elf32_Dyn::d_type == DT_REL(.rel.dyn) 与 DT_JMP_REL(.rel.plt).&lt;/p&gt;

&lt;p&gt;Elf32_Rel中保存了导出函数的offset, 和对应的symbol_table_index以及rel_type(类型).  这里的关键是symbol_table_index.&lt;/p&gt;

&lt;p&gt;通过hash table把要HOOK的函数名(符号名)转为对应的symbol_table_index, 然后遍历Elf32_Dyn数组中的DT_REL与DT_JMP_REL中找到与之对应的项, 该项中的Elf32_Rel::r_offset中指向了一个sizeof(Elf32_Addr)长度的地址, 该地址存放的正是导入函数的地址. 所以执行如下便可完成hook:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; *(Elf32_Addr*)(base + Elf32_Rel::r_offset ) = New_Fun_Ptr ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;补充:&lt;/strong&gt; 以上方法只能HOOK到静态调用, 对于通过dlsym()获取函数指针的调用方法可以通过如下方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  修改&amp;quot;导入函数&amp;quot;所在的模块中用于描述该导出函数信息的Elf32_Dym对象, 然后修改其Elf32_Sym::st_value, 这样可以将dlsym()方式一并HOOK. (见下面的&amp;quot;导出函数&amp;quot;HOOK方法)

  要么使用inline hook解决一切麻烦.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导出函数的offset地址存储在Elf32_Sym::st_value中( Elf32_Sym::st_shndx != SHN_UNDEF 表明该Elf32_Sym存储的是一个导出函数项(android的linker源码中这样处理). 根据实际观察，通常导出函数的st_shndx为8. ), 导出函数所在Elf32_Sym结构的定位与上面导入函数的寻找方式一样, 都是通过hash table. 最后修改方法如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; *(Elf32_Addr*) Elf32_Sym::st_value = New_Fun_Ptr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;补充:&lt;/strong&gt; 以上方法只能在对文件进行HOOK, 因为当自身模块代码运行之前, Elf32_Sym::st_value已经被linker填充到了调用方的GOT表中了. 补充方法有二, 要么HOOK调用方的导入, 要么实施inline hook, 对进程内所有调用都有效.&lt;/p&gt;

&lt;h2 id=&#34;4-总结:d797541984d2426be471f97863bea3b7&#34;&gt;4. 总结:&lt;/h2&gt;

&lt;p&gt;此HOOK导入 等于 彼HOOK导出. 具体怎么实施HOOK看发起方是谁.  最后 inline hook 大法好!.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java混淆/反混淆/加固 总结</title>
      <link>https://pkiller.com/android/Java%E6%B7%B7%E6%B7%86%E6%8A%80%E5%B7%A7-%E5%8F%8D%E6%B7%B7%E6%B7%86-%E5%8A%A0%E5%9B%BA%20%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 18 Jun 2016 08:36:15 +0800</pubDate>
      
      <guid>https://pkiller.com/android/Java%E6%B7%B7%E6%B7%86%E6%8A%80%E5%B7%A7-%E5%8F%8D%E6%B7%B7%E6%B7%86-%E5%8A%A0%E5%9B%BA%20%E6%80%BB%E7%BB%93/</guid>
      <description>

&lt;h2 id=&#34;混淆手段:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;混淆手段&lt;/h2&gt;

&lt;h3 id=&#34;定义超长类名:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;定义超长类名&lt;/h3&gt;

&lt;p&gt;可以造成超长文件名, 造成常规反编译工具失败(路径太长).
例子: oooooooooooooo&lt;/p&gt;

&lt;h3 id=&#34;找茬:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;找茬&lt;/h3&gt;

&lt;p&gt;OoOoOoooOOooo
&lt;strong&gt;$$_$$&lt;/strong&gt;$&lt;em&gt;$$&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;使用java关键字:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;使用Java关键字&lt;/h3&gt;

&lt;p&gt;java对关键字检查操作在编译时, 所以在编译后修改没有问题.&lt;/p&gt;

&lt;h3 id=&#34;unicode字符:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;Unicode字符&lt;/h3&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;cjk-china-japan-korea-字符:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;CJK(China Japan korea)字符&lt;/h3&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;其他少见字符:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;其他少见字符&lt;/h3&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;盲文点字符:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;盲文点字符&lt;/h3&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;识别类名:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;识别类名&lt;/h3&gt;

&lt;p&gt;通过源码中保留的Log.d(tag, &amp;ldquo;xx&amp;rdquo;); 通常程序员会将tag写为所在class名.&lt;/p&gt;

&lt;h3 id=&#34;识别enum:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;识别Enum&lt;/h3&gt;

&lt;p&gt;构建Enum的第二个参数是成员名.&lt;/p&gt;

&lt;h3 id=&#34;acc-bridge:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;ACC_BRIDGE&lt;/h3&gt;

&lt;p&gt;标识的函数会调用另外一个, 两个函数同名.&lt;/p&gt;

&lt;h3 id=&#34;getter-setter:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;Getter/Setter&lt;/h3&gt;

&lt;p&gt;成员与函数同名&lt;/p&gt;

&lt;h3 id=&#34;根据日志:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;根据日志&lt;/h3&gt;

&lt;p&gt;&amp;hellip;.&lt;/p&gt;

&lt;h3 id=&#34;字符串加密:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;字符串加密&lt;/h3&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;asset加密:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;Asset加密&lt;/h3&gt;

&lt;p&gt;加密文件, 在打开文件函数处注入解密代码.  达到无缝加密. 分析并解密&lt;/p&gt;

&lt;h3 id=&#34;androidmanifest-xml中namespace-name被清除:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;AndroidManifest.xml中namespace:name被清除.&lt;/h3&gt;

&lt;p&gt;该文件中同时包含ResourceId(Android特有)和namespace/name(标准xml特有)两套访问方式, 而Android中大部分使用resourceId, 该ResourceId对应了文本资源中的namaspace/name字符串。&lt;/p&gt;

&lt;h3 id=&#34;函数合并:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;函数合并&lt;/h3&gt;

&lt;p&gt;合并函数调用&lt;/p&gt;

&lt;h3 id=&#34;利用java函数重载:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;利用Java函数重载&lt;/h3&gt;

&lt;p&gt;在java中, 函数以 &amp;ldquo;函数名+参数列表&amp;rdquo; 为sig(函数名相同, 参数不同可构成重载). 而在smali(bytecodes)中, 函数则以 &amp;ldquo;函数名+参数列表+返回类型&amp;rdquo; 为sig.
因此直接在编译后的smali(bytecodes)上动手, 将具有相同&amp;rdquo;函数列表&amp;rdquo;的函数改为同名. 这样在smali中可以正常执行, 但还原为java后, 会因为有多个相同&amp;rdquo;函数名+参数列表&amp;rdquo;而产生冲突.&lt;/p&gt;

&lt;h2 id=&#34;反混淆手段:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;反混淆手段&lt;/h2&gt;

&lt;h3 id=&#34;借助jeb简化混淆的命名:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;借助JEB简化混淆的命名&lt;/h3&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;借助proguard简化混淆的命名:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;借助Proguard简化混淆的命名&lt;/h3&gt;

&lt;p&gt;如果混淆字符长期且复杂, 可以先用Proguard混淆一把, 简化复杂度.&lt;/p&gt;

&lt;p&gt;通过Proguard keep class *(不混淆任何东西)来输出mapping表文件.(目的是为了修改mapping表中的对应名称来达到整体修改工程中名称的目的)&lt;/p&gt;

&lt;p&gt;通过分析得到类的有意义名称, 然后将其修改至mapping文件, 最后利用Proguard来帮助批量修改回代码.&lt;/p&gt;

&lt;h2 id=&#34;加固:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;加固&lt;/h2&gt;

&lt;h3 id=&#34;dalvik-bug:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;&amp;ldquo;dalvik&amp;rdquo;bug&lt;/h3&gt;

&lt;p&gt;利用&amp;rdquo;dalvik&amp;rdquo;bug使其可以运行, 但不能够被反编译.&lt;/p&gt;

&lt;h3 id=&#34;dex超长数组:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;dex超长数组&lt;/h3&gt;

&lt;p&gt;定义超长数组可以使不少工具反编译失败(耗尽其内存), 实际运行中要在入口将其释放, 以免内存太大无法运行.&lt;/p&gt;

&lt;h3 id=&#34;elf清除或畸形化section:8ab83e4bc2022a61fc42fc0d15c45011&#34;&gt;elf清除或畸形化section&lt;/h3&gt;

&lt;p&gt;清除或填充为畸形, 可使IDA和gikdbg.art等发生崩溃或无法正常解析. 可参见笔记: IDA - 打开畸形ELF时的报错信息含义&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>