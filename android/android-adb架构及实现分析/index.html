<!DOCTYPE HTML>
<html lang="zh-CN">
<head>

  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-146336292-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-146336292-1');
</script>

  <meta charset="UTF-8">
  <title>Android Adb 架构及实现分析 - pkiller</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
  <meta name="keywords" content="android,adb,android-debug-bridge,adb分析,adb定制,adb原理,">
  <meta name="description" content="一、基本概念 Adb(Android-Debug-Bridge)是为了方便Host与目标Android设备通讯而出现的一种套件，支持USB与T">
  
  <meta itemprop="name" content="Android Adb 架构及实现分析 - pkiller">
  <meta itemprop="description" content="一、基本概念 Adb(Android-Debug-Bridge)是为了方便Host与目标Android设备通讯而出现的一种套件，支持USB与T">
  <meta itemprop="image" content="https://pkiller.com/img/author.jpg">
  
  
  <meta name="twitter:description" content="">
  
  <link rel="shortcut icon" href="https://pkiller.com/img/favicon.ico"/>
  <link rel="apple-touch-icon" href="https://pkiller.com/apple-touch-icon.png" />
  <link rel="apple-touch-icon-precomposed" href="https://pkiller.com/apple-touch-icon.png" />
  <link rel="stylesheet" href="https://pkiller.com/highlight/styles/github.css">
  <script src="https://pkiller.com/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  
  <link rel="stylesheet" href="https://pkiller.com/font/hack/css/hack.min.css">
  <link rel="stylesheet" href="https://pkiller.com/css/style.css">
</head>

<body>
  <header>
    <div>
  
  <div id="imglogo">
    <a href="https://pkiller.com/"><img src="https://pkiller.com/img/logo.svg" alt="pkiller" title="pkiller"/></a>
  </div>
  
  <div id="textlogo">
    <h1 class="site-name"><a href="https://pkiller.com/" title="pkiller">pkiller</a></h1>
    <h2 class="blog-motto">个人技术博客</h2>
  </div>
  <div class="navbar"><a class="navbutton navmobile" href="#" title="menu"></a></div>
  <nav class="animated">
    <ul>
      
      <li><a href="/android">Android</a></li>
      
      <li><a href="/security">安全</a></li>
      
      <li><a href="/music">音乐</a></li>
      
      <li><a href="/other">杂项</a></li>
      
      <li><a href="/about">关于</a></li>
      
      <li>
        <form class="search" method="get" action="https://www.google.com/search">
          <div>
            <input type="text" id="search" name="q" placeholder="搜索">
          </div>
        </form>
      </li>
    </ul>
  </nav>
</div>

  </header>
  <div id="container">
    <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody">
    <header class="article-info clearfix">
  <h1 itemprop="name">
      <a href="https://pkiller.com/android/android-adb%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/" title="Android Adb 架构及实现分析" itemprop="url">Android Adb 架构及实现分析</a>
  </h1>
  <p class="article-author">By
    
      <a href="" title=""></a>
    
  </p>
  <p class="article-time">
    <time datetime="2018-08-14 23:00:48 &#43;0800 CST" itemprop="datePublished">2018年08月14日</time>
  </p>
</header>

	<div class="article-content">
    
    

<h2 id="一-基本概念">一、基本概念</h2>

<p>Adb(Android-Debug-Bridge)是为了方便Host与目标Android设备通讯而出现的一种套件，支持USB与TCP/IP的通讯的方式。Adb分为三个端：Client &amp; Server &amp; Mobile。Adb的部分源代码是混在一起的，很多部分的功能可以重用，各端独立的逻辑使用预编译指令来分隔离。源码中通常使用预编译定义<code>ADB_HOST</code>来表示PC上的代码，其他#else块中表示Mobile代码，其他的表示为3端共享的代码。
在本文中我们将adb一共分为三部分，但实际上在Mobile中也包含adb, 即Client和Server端。也就是说可以使用Mobile调试Mobile。但是为了便于理解，不混淆概念故将其简化为Mobile和PC端。实际应当以HOST来表示adb也就是调试人员所使用的机器。源码中也会用<code>HOST_ON_TARGET</code>预编译定义来表示运行在Mobile设备中的adb(Server&amp;Client).</p>

<p><img src="1.png" alt="img" title="img" /></p>

<p><img src="2.png" alt="img" title="img" /></p>

<h3 id="a-pc端">A. PC端</h3>

<p>Adb Server 与 Adb Client，二者为同一个binary文件即adb或adb.exe，通过启动参数来区分角色.
Server为Client提供服务的端口为： 5037(PC端) 或 5038(Mobile端).</p>

<h3 id="b-mobile端">B. Mobile端</h3>

<p>Adbd，提供最终的adb命令实现.</p>

<h3 id="c-连接模式">C. 连接模式</h3>

<p>分为两种:</p>

<ul>
<li>USB模式, PC通过USB与Mobile通讯.  模式依据：Mobile中<code>service.adb.tcp.port</code>值为0  (property)</li>
<li>TCP/IP模式, PC通过tcp/ip与Mobile进行通讯.  模式依据：Mobile中<code>service.adb.tcp.port</code>值为port number  (property)</li>
</ul>

<h2 id="二-基本用法">二、基本用法</h2>

<h3 id="a-切换为tcp-ip模式">A. 切换为TCP/IP模式</h3>

<p>切换为TCP/IP模式：</p>

<pre><code class="language-bash">adb tcpip 6666  # 将当前已连接USB上的Mobile端切换为TCP/IP模式，以6666端口进行监听.
</code></pre>

<p>切换后，断开USB链接，并使用TCP/IP重新连接设备：</p>

<pre><code class="language-bash">adb kill-server
adb connect 192.168.125.236:6666 
</code></pre>

<h2 id="三-android中相关的property">三、Android中相关的property</h2>

<h3 id="a-adbd是否拥有root权限">A. adbd是否拥有ROOT权限</h3>

<p><code>/xbin/adbd</code>文件拥有s标志位, 所以默认以root权限启动的，启动后会根据Propterty值决定是否降权到SHELL权限。
相关Property:  <code>ro.secure</code> &amp; <code>ro.debuggable</code> &amp; <code>service.adb.root</code></p>

<p><strong>adbd决定是否降权到shell的逻辑：</strong></p>

<pre><code class="language-c"># 伪代码
if  ro.secure==1 &amp;&amp; (ro.debuggable==0 || service.adb.root==0)
{
    # drop privileges
    setgid(AID_SHELL);
    setuid(AID_SHELL);
} 
</code></pre>

<p>以下是源码中判断降权的逻辑：</p>

<pre><code class="language-c"># xref: /system/core/adb/adb.c
int adb_main(int is_daemon, int server_port) {
// ...
    /* don't listen on a port (default 5037) if running in secure mode */
    /* don't run as root if we are running in secure mode */
    if (should_drop_privileges()) {
        drop_capabilities_bounding_set_if_needed();
        // -------------降权----------------
        /* then switch user and group to &quot;shell&quot; */
        if (setgid(AID_SHELL) != 0) {
            exit(1);
        }
        if (setuid(AID_SHELL) != 0) {
            exit(1);
        }

        D(&quot;Local port disabled\n&quot;);
    } else {
// ...
}

static int should_drop_privileges() {
#ifndef ALLOW_ADBD_ROOT
    return 1;
#else /* ALLOW_ADBD_ROOT */
    int secure = 0;
    char value[PROPERTY_VALUE_MAX];

   /* run adbd in secure mode if ro.secure is set and
    ** we are not in the emulator
    */
    property_get(&quot;ro.kernel.qemu&quot;, value, &quot;&quot;);
    if (strcmp(value, &quot;1&quot;) != 0) {
        property_get(&quot;ro.secure&quot;, value, &quot;1&quot;);
        if (strcmp(value, &quot;1&quot;) == 0) {
            // don't run as root if ro.secure is set...
            secure = 1;

            // ... except we allow running as root in userdebug builds if the
            // service.adb.root property has been set by the &quot;adb root&quot; command
            property_get(&quot;ro.debuggable&quot;, value, &quot;&quot;);
            if (strcmp(value, &quot;1&quot;) == 0) {
                property_get(&quot;service.adb.root&quot;, value, &quot;&quot;);
                if (strcmp(value, &quot;1&quot;) == 0) {
                    secure = 0;
                }
            }
        }
    }
    return secure;
#endif /* ALLOW_ADBD_ROOT */
}
#endif /* !ADB_HOST */
</code></pre>

<h3 id="b-adb连接时-是否需要进行需要用户授权验证">B. adb连接时，是否需要进行需要用户授权验证</h3>

<p>相关Property: <code>ro.adb.secure</code></p>

<blockquote>
<p>允许USB调试吗？</p>

<p>这台计算机的RSA密钥指纹如下:
23:B2:47:E1:08:DE:5A:3B:58:5A:A5:A6:FA:98:E0:50</p>

<p>一律允许使用这台计算机进行调试</p>
</blockquote>

<ul>
<li>1: 需要授权</li>
<li>0: 不需要</li>
</ul>

<h3 id="c-adb的连接模式">C. adb的连接模式</h3>

<p>相关Property: <code>service.adb.tcp.port</code>、<code>persist.adb.tcp.port</code>
adbd以何种模式进行工作：</p>

<ul>
<li>为0: 以USB模式工作<br /></li>
<li>不为0: 以TCP/IP模式工作, 并且此值作为监听端口</li>
</ul>

<p><strong>adb决定使用TCP/IP模式的逻辑：</strong></p>

<pre><code class="language-c"># 伪代码
if (service.adb.tcp.port != null ? service.adb.tcp.port : persist.adb.tcp.port) &gt; 0
{
    # it's tcp/ip mode.
} 
</code></pre>

<p>以下是源码中选择模式的逻辑：</p>

<pre><code class="language-c">// xref: /system/core/adb/adb.c
int adb_main(int is_daemon, int server_port)
{
    // ...
   int usb = 0;
    // 当存在/dev/android_adb或/dev/usb-ffs/adb/ep0时, 先预设为USB模式
    if (access(USB_ADB_PATH, F_OK) == 0 || access(USB_FFS_ADB_EP0, F_OK) == 0) {
        // listen on USB
        usb_init();
        usb = 1;
    }

    // 若port不为0，则使用TCP/IP模式，否则维持USB模式.
    // If one of these properties is set, also listen on that port
    // If one of the properties isn't set and we couldn't listen on usb,
    // listen on the default port.
    property_get(&quot;service.adb.tcp.port&quot;, value, &quot;&quot;);
    if (!value[0]) {
        property_get(&quot;persist.adb.tcp.port&quot;, value, &quot;&quot;);
    }
    if (sscanf(value, &quot;%d&quot;, &amp;port) == 1 &amp;&amp; port &gt; 0) {
        printf(&quot;using port=%d\n&quot;, port);
        // listen on TCP port specified by service.adb.tcp.port property
        local_init(port);
    } else if (!usb) {
        // listen on default port
        local_init(DEFAULT_ADB_LOCAL_TRANSPORT_PORT);
    }
    // ...
}
</code></pre>

<h3 id="d-adbd-是否运行中">D. Adbd 是否运行中</h3>

<p>相关Property: <code>init.svc.adbd</code>
例子：</p>

<pre><code class="language-bash">[init.svc.adbd]: [running]
</code></pre>

<h3 id="e-adb是否被打开">E. Adb是否被打开</h3>

<p>相关Property: <code>sys.usb.state</code>
例子：</p>

<pre><code class="language-bash">[sys.usb.state]: [mtp,adb]
</code></pre>

<p>该项显示了usb上所有支持的功能，以逗号分割。如上如果adb打开，则会出现adb字样</p>

<h2 id="四-adb的开启-关闭">四、Adb的开启/关闭</h2>

<p>在Android中，当Mobile通过USB连接到PC后，到底开启哪些功能(如：adbd、midi、mtp等) 都是由<code>UsbDeviceManager</code>来做总控的。而<code>UsbDeviceManager</code>对这些功能控制的方式就是通过修改<code>property</code>。adbd会根据相关preoperty项作出相应操作，从而决定是否被打开。那么adbd是如何响应property的更改呢？ 这主要依赖<code>init.usb.rc</code>或<code>init.*.usb.rc</code>在一开机就注册好的property事件，当指定的property项如<code>sys.usb.config</code>的值被设为<code>mtp,usb</code>时，就会触发启动adbd的命令。</p>

<p><img src="3.png" alt="img" title="img" /></p>

<p><strong>首先介绍打开adb的大体流程：</strong></p>

<ul>
<li>流程从Settings开始，在“开发者选项”中点击打开“USB调试”选项打开。</li>
<li>Settings将<code>Settings.Global.DEVELOPMENT_SETTINGS_ENABLED</code>配置更新到Preference，并最后调用回调广而告之。</li>
<li>此时运行于system_server进程中的UsbDeviceManager收到了ADB_ENABLE被修改的事件后，马上进行更新property: sys.usb.config的值，假如原value为“mtp”，更新完成后变为&rdquo;mtp, adb&rdquo;。</li>
<li>此时init.usb.rc进程收到property被修改的事件，立刻执行预设好的shell命令(如上图中的&rdquo;start adbd&rdquo;)。最后更新sys.usb.state的值，使之与sys.usb.state相同，表明所有任务已完成。</li>
</ul>

<p><strong>以下是UsbDeviceManager之后开始的详细代码流程：</strong></p>

<p>在Settings中，控制adb开关都是通过framework.jar中的<code>UsbManager::setCurrentFunction()</code>达成的，最后会通过Binder调用至system_server中的<code>UsbService::setCurrentFunction()</code>。</p>

<p><strong>1. 如果此时adb已为开启状态，就认为本次的调用目的是为了关闭adb()。如果为关闭状态，就认为本次是为了打开adb:</strong></p>

<pre><code class="language-java">xref: /frameworks/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java
        private void setEnabledFunctions(String functions, boolean makeDefault) {
                // ...
                if (mAdbEnabled) {
                    functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);
                } else {
                    functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);
                }
                // ...
        }
</code></pre>

<p><strong>2. 假设目前为打开adb操作，在<code>sys.usb.config</code>值的尾部拼接&rdquo;,adb&rdquo;，并更新该property值:</strong></p>

<pre><code class="language-java">// xref: /frameworks/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java
     private static String addFunction(String functions, String function) {
         if (&quot;none&quot;.equals(functions)) {
             return function;
         }
        if (!containsFunction(functions, function)) {
            if (functions.length() &gt; 0) {
                functions += &quot;,&quot;;
            }
            functions += function;
        }
        return functions;
    }
</code></pre>

<p><strong>3. 然后开启线程，循环每隔50ms监控<code>sys.usb.state</code>的值是否与<code>sys.usb.config</code>相等了。(如果相等表明property修改的事件被成功响应了):</strong></p>

<pre><code class="language-java">// xref: /frameworks/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java
        private boolean waitForState(String state) {
            // wait for the transition to complete.
            // give up after 1 second.
            for (int i = 0; i &lt; 20; i++) {
                // State transition is done when sys.usb.state is set to the new configuration
                if (state.equals(SystemProperties.get(&quot;sys.usb.state&quot;))) return true;
                SystemClock.sleep(50);
            }
            Slog.e(TAG, &quot;waitForState(&quot; + state + &quot;) FAILED&quot;);
            return false;
        }
</code></pre>

<p><strong>4. 然后流程来到<code>init.*.usb.rc</code>中:</strong></p>

<p>以下的脚本片段为其中的一段，大致含义之当property<code>sys.usb.config</code>的值为<code>&quot;mtp,adb&quot;</code>时，触发以下块内的脚本</p>

<pre><code class="language-bash">on property:sys.usb.config=mtp,adb
    write /sys/class/android_usb/android0/enable 0
    write /sys/class/android_usb/android0/idVendor 18D1  # 设置厂商ID，以便PC端可以正常识别
    write /sys/class/android_usb/android0/idProduct 4EE2 
    write /sys/class/android_usb/android0/bDeviceClass 0
    write /sys/class/android_usb/android0/bDeviceSubClass 0
    write /sys/class/android_usb/android0/bDeviceProtocol 0
    write /sys/class/android_usb/android0/functions mtp,adb
    write /sys/class/android_usb/android0/enable 1
    start adbd  # 启动adbd
    setprop sys.usb.state ${sys.usb.config}  # 最后更新当前usb的状态值
</code></pre>

<p>以上就是adb的开关原理，主要是依赖于init脚本的事件来实现。</p>

<h2 id="五-adbd-与-server-的授权过程">五、Adbd 与 Server 的授权过程</h2>

<p><img src="4.png" alt="img" title="img" /></p>

<ul>
<li><p>当Mobile插入PC后，双方检测到Adb连接发生：</p></li>

<li><p>1.Mobile向PC发送随机<code>AUTH TOKEN</code></p></li>

<li><p>2.PC收到<code>AUTH TOKEN</code>后使用私钥(<code>~/.android/adbkey</code>)对Token计算<code>SIGNATURE</code>, 并计算Tokne的SHA-1，将结果发回Mobile.</p></li>
</ul>

<p><img src="5.png" alt="img" title="img" /></p>

<ul>
<li>3.Mobile根据PC名检查是否<code>保存过/授权过</code>PC的公钥(从<code>/data/misc/adb/adb_keys</code>中读取已保存的授权)。如果已授权过，流程直接跳到第7步。否则到下一步进行新授权.</li>
</ul>

<p><img src="6.png" alt="img" title="img" /></p>

<ul>
<li>4.Mobile发送<code>UNAUTHORIZED</code>到PC</li>
<li>5.PC收到<code>UNAUTHORIZED</code>后将<code>RSA PUBLICKEY</code>(<code>~/.android/adbkey.pub</code>)发往Mobile</li>
<li>6.Mobile收到新的<code>RSA PUBLICKEY</code>后计算HASH，并弹出<code>允许USB调试吗？</code>的对话框请求用户允许，进行下一步，否则流程终止/连接失败</li>
<li>7.Mobile向PC发送<code>ONLINE</code>状态，双方授权验证完成，连接成功</li>
</ul>

<p><img src="7.png" alt="img" title="img" /></p>

<p><img src="8.png" alt="img" title="img" /></p>

<h2 id="六-pc端adb-server流程">六、PC端Adb Server流程</h2>

<ul>
<li>Adb Server在首次调用Adb命令的时候被启动， Adb Client与Adb Server共用一个binary文件，由参数区分角色(Client/Server)。</li>
<li>Adb Server由Adb Client通过命令<code>adb -P 5037 fork-server server</code>进行启动(默认的Adb Server监听端口为5037)。</li>
</ul>

<h3 id="a-adb-server-启动流程">A. Adb Server 启动流程</h3>

<pre><code class="language-c">// xref: /system/core/adb/commandline.c
int adb_main(int is_daemon, int server_port)
{

#if ADB_HOST
   // 在PC上运行的ADB流程
    usb_vendors_init();   // 初始化各手机厂商的vendor id号， 以便adb能从已插入的usb设备中识别出手机
    usb_init();  // 开启对usb设备的监控(每隔1ms遍历一次/dev/bus/usb)
    local_init(DEFAULT_ADB_LOCAL_TRANSPORT_PORT);  // 首次尝试连接本地的Android模拟器(向localhost:5555端口发起链接)， #define DEFAULT_ADB_LOCAL_TRANSPORT_PORT 5555
    adb_auth_init();  // 初始化公钥文件，

    char local_name[30];
    build_local_name(local_name, sizeof(local_name), server_port);
    if(install_listener(local_name, &quot;*smartsocket*&quot;, NULL, 0)) {
        exit(1);
    }
#else
   // ...

}
</code></pre>

<p><strong>1. 初始化各厂商手机的USB的Vender ID号，除了内置了一批常见ID外，还会从<code>~/.android/adb_usb.ini</code>读取，以便用户添加不常见的设备。</strong></p>

<p>如下， 内置的一批Vendor ID</p>

<pre><code class="language-c">// xref: /system/core/adb/usb_vendors.c
/* Keep the list below sorted alphabetically by #define name */
// Acer's USB Vendor ID
#define VENDOR_ID_ACER          0x0502
// Allwinner's USB Vendor ID
#define VENDOR_ID_ALLWINNER     0x1F3A
// Amlogic's USB Vendor ID
#define VENDOR_ID_AMLOGIC       0x1b8e
// AnyDATA's USB Vendor ID
#define VENDOR_ID_ANYDATA       0x16D5
// Archos's USB Vendor ID
#define VENDOR_ID_ARCHOS        0x0E79
// Asus's USB Vendor ID
#define VENDOR_ID_ASUS          0x0b05
// BYD's USB Vendor ID
#define VENDOR_ID_BYD           0x1D91
// Compal's USB Vendor ID
#define VENDOR_ID_COMPAL        0x04B7
// Compalcomm's USB Vendor ID
#define VENDOR_ID_COMPALCOMM    0x1219
// Dell's USB Vendor ID
#define VENDOR_ID_DELL          0x413c
// ECS's USB Vendor ID
#define VENDOR_ID_ECS           0x03fc
// EMERGING_TECH's USB Vendor ID
#define VENDOR_ID_EMERGING_TECH 0x297F
// Emerson's USB Vendor ID
#define VENDOR_ID_EMERSON       0x2207
// Foxconn's USB Vendor ID
#define VENDOR_ID_FOXCONN       0x0489
// Fujitsu's USB Vendor ID
#define VENDOR_ID_FUJITSU       0x04C5
// Funai's USB Vendor ID
#define VENDOR_ID_FUNAI         0x0F1C
// Garmin-Asus's USB Vendor ID
#define VENDOR_ID_GARMIN_ASUS   0x091E
// Gigabyte's USB Vendor ID
#define VENDOR_ID_GIGABYTE      0x0414
// Gigaset's USB Vendor ID
#define VENDOR_ID_GIGASET       0x1E85
// GIONEE's USB Vendor ID
#define VENDOR_ID_GIONEE        0x271D
// Google's USB Vendor ID
#define VENDOR_ID_GOOGLE        0x18d1
// Haier's USB Vendor ID
#define VENDOR_ID_HAIER         0x201E
// Harris's USB Vendor ID
#define VENDOR_ID_HARRIS        0x19A5
// Hisense's USB Vendor ID
#define VENDOR_ID_HISENSE       0x109b
// Honeywell's USB Vendor ID
#define VENDOR_ID_HONEYWELL     0x0c2e
// HP's USB Vendor ID
#define VENDOR_ID_HP            0x03f0
// HTC's USB Vendor ID
#define VENDOR_ID_HTC           0x0bb4
// Huawei's USB Vendor ID
#define VENDOR_ID_HUAWEI        0x12D1
// INQ Mobile's USB Vendor ID
#define VENDOR_ID_INQ_MOBILE    0x2314
// Intel's USB Vendor ID
#define VENDOR_ID_INTEL         0x8087
// Intermec's USB Vendor ID
#define VENDOR_ID_INTERMEC      0x067e
// IRiver's USB Vendor ID
#define VENDOR_ID_IRIVER        0x2420
// K-Touch's USB Vendor ID
#define VENDOR_ID_K_TOUCH       0x24E3
// KT Tech's USB Vendor ID
#define VENDOR_ID_KT_TECH       0x2116
// Kobo's USB Vendor ID
#define VENDOR_ID_KOBO          0x2237
// Kyocera's USB Vendor ID
#define VENDOR_ID_KYOCERA       0x0482
// Lab126's USB Vendor ID
#define VENDOR_ID_LAB126        0x1949
// Lenovo's USB Vendor ID
#define VENDOR_ID_LENOVO        0x17EF
// LenovoMobile's USB Vendor ID
#define VENDOR_ID_LENOVOMOBILE  0x2006
// LG's USB Vendor ID
#define VENDOR_ID_LGE           0x1004
// Lumigon's USB Vendor ID
#define VENDOR_ID_LUMIGON       0x25E3
// Motorola's USB Vendor ID
#define VENDOR_ID_MOTOROLA      0x22b8
// MSI's USB Vendor ID
#define VENDOR_ID_MSI           0x0DB0
// MTK's USB Vendor ID
#define VENDOR_ID_MTK           0x0e8d
// NEC's USB Vendor ID
#define VENDOR_ID_NEC           0x0409
// B&amp;N Nook's USB Vendor ID
#define VENDOR_ID_NOOK          0x2080
// Nvidia's USB Vendor ID
#define VENDOR_ID_NVIDIA        0x0955
// OPPO's USB Vendor ID
#define VENDOR_ID_OPPO          0x22D9
// On-The-Go-Video's USB Vendor ID
#define VENDOR_ID_OTGV          0x2257
// OUYA's USB Vendor ID
#define VENDOR_ID_OUYA          0x2836
// Pantech's USB Vendor ID
#define VENDOR_ID_PANTECH       0x10A9
// Pegatron's USB Vendor ID
#define VENDOR_ID_PEGATRON      0x1D4D
// Philips's USB Vendor ID
#define VENDOR_ID_PHILIPS       0x0471
// Panasonic Mobile Communication's USB Vendor ID
#define VENDOR_ID_PMC           0x04DA
// Positivo's USB Vendor ID
#define VENDOR_ID_POSITIVO      0x1662
// Prestigio's USB Vendor ID
#define VENDOR_ID_PRESTIGIO     0x29e4
// Qisda's USB Vendor ID
#define VENDOR_ID_QISDA         0x1D45
// Qualcomm's USB Vendor ID
#define VENDOR_ID_QUALCOMM      0x05c6
// Quanta's USB Vendor ID
#define VENDOR_ID_QUANTA        0x0408
// Rockchip's USB Vendor ID
#define VENDOR_ID_ROCKCHIP      0x2207
// Samsung's USB Vendor ID
#define VENDOR_ID_SAMSUNG       0x04e8
// Sharp's USB Vendor ID
#define VENDOR_ID_SHARP         0x04dd
// SK Telesys's USB Vendor ID
#define VENDOR_ID_SK_TELESYS    0x1F53
// Smartisan's USB Vendor ID
#define VENDOR_ID_SMARTISAN     0x29a9
// Sony's USB Vendor ID
#define VENDOR_ID_SONY          0x054C
// Sony Ericsson's USB Vendor ID
#define VENDOR_ID_SONY_ERICSSON 0x0FCE
// T &amp; A Mobile Phones' USB Vendor ID
#define VENDOR_ID_T_AND_A       0x1BBB
// TechFaith's USB Vendor ID
#define VENDOR_ID_TECHFAITH     0x1d09
// Teleepoch's USB Vendor ID
#define VENDOR_ID_TELEEPOCH     0x2340
// Texas Instruments's USB Vendor ID
#define VENDOR_ID_TI            0x0451
// Toshiba's USB Vendor ID
#define VENDOR_ID_TOSHIBA       0x0930
// Unowhy's USB Vendor ID
#define VENDOR_ID_UNOWHY        0x2A49
// Vizio's USB Vendor ID
#define VENDOR_ID_VIZIO         0xE040
// Wacom's USB Vendor ID
#define VENDOR_ID_WACOM         0x0531
// Xiaomi's USB Vendor ID
#define VENDOR_ID_XIAOMI        0x2717
// YotaDevices's USB Vendor ID
#define VENDOR_ID_YOTADEVICES   0x2916
// Yulong Coolpad's USB Vendor ID
#define VENDOR_ID_YULONG_COOLPAD 0x1EBF
// ZTE's USB Vendor ID
#define VENDOR_ID_ZTE           0x19D2
/* Keep the list above sorted alphabetically by #define name */
</code></pre>

<p><strong>2. 启动新线程，监控usb中出现的手机：</strong></p>

<p>每隔1秒，从/dev/bus/usb扫描一次新增的USB设备.</p>

<pre><code class="language-c">// xref: /system/core/adb/usb_linux.c
void* device_poll_thread(void* unused)
{
    D(&quot;Created device thread\n&quot;);
    for(;;) {
            /* XXX use inotify */
        find_usb_device(&quot;/dev/bus/usb&quot;, register_device);  //每隔1秒， 扫描一次新增USB设备
        kick_disconnected_devices();
        sleep(1);
    }
    return NULL;
}

static void find_usb_device(const char *base,
        void (*register_device_callback)
                (const char *, const char *, unsigned char, unsigned char, int, int, unsigned))
{
    char busname[32], devname[32];
    unsigned char local_ep_in, local_ep_out;
    DIR *busdir , *devdir ;
    struct dirent *de;
    int fd ;

    busdir = opendir(base);
    if(busdir == 0) return;

    while((de = readdir(busdir)) != 0) {
        if(badname(de-&gt;d_name)) continue;

        snprintf(busname, sizeof busname, &quot;%s/%s&quot;, base, de-&gt;d_name);
        devdir = opendir(busname);
        if(devdir == 0) continue;

//        DBGX(&quot;[ scanning %s ]\n&quot;, busname);
        while((de = readdir(devdir))) {
            unsigned char devdesc[4096];
            unsigned char* bufptr = devdesc;
            unsigned char* bufend;
            struct usb_device_descriptor* device;
            struct usb_config_descriptor* config;
            struct usb_interface_descriptor* interface;
            struct usb_endpoint_descriptor *ep1, *ep2;
            unsigned zero_mask = 0;
            unsigned vid, pid;
            size_t desclength;
   // ...
}
</code></pre>

<p><strong>3、初始化adb的public key，以便后续与手机进行授权握手：</strong></p>

<pre><code class="language-c">// xref: /system/core/adb/adb_auth_host.c
static int get_user_keyfilepath(char *filename, size_t len)
{
    const char *format, *home;
    char android_dir[PATH_MAX];
    struct stat buf;
#ifdef _WIN32
    char path[PATH_MAX];
    home = getenv(&quot;ANDROID_SDK_HOME&quot;);
    if (!home) {
        SHGetFolderPath(NULL, CSIDL_PROFILE, NULL, 0, path);
        home = path;
    }
    format = &quot;%s\\%s&quot;;
#else
    home = getenv(&quot;HOME&quot;);
    if (!home)
        return -1;
    format = &quot;%s/%s&quot;;
#endif

    D(&quot;home '%s'\n&quot;, home);
    
    if (snprintf(android_dir, sizeof(android_dir), format, home,
                        ANDROID_PATH) &gt;= (int)sizeof(android_dir))
        return -1;

    if (stat(android_dir, &amp;buf)) {
        if (adb_mkdir(android_dir, 0750) &lt; 0) {
            D(&quot;Cannot mkdir '%s'&quot;, android_dir);
            return -1;
        }
    }

    // 拼接得出～/.android/adbkey
    return snprintf(filename, len, format, android_dir, ADB_KEY_FILE);
}
</code></pre>

<p><strong>4、开启socket并开启事件循环，接受Client连接和发来的命令.</strong></p>

<pre><code class="language-c">// xref: /system/core/adb/fdevent.c
void fdevent_loop()
{
    fdevent *fde;
    fdevent_subproc_setup();

    for(;;) {
        D(&quot;--- ---- waiting for events\n&quot;);

        fdevent_process();

        while((fde = fdevent_plist_dequeue())) {
            fdevent_call_fdfunc(fde);
        }
    }
}
</code></pre>

<h2 id="七-mobile端adbd流程">七、Mobile端Adbd流程</h2>

<p><strong>1. adbd是由init进程启动，启动方式在init.rc中定义：</strong></p>

<ul>
<li>首先init会帮忙创建一个名为adbd的unix socket(system system)</li>

<li><p>然后启动adbd进程，并且将上面的socket传给adbd进程</p>

<pre><code class="language-bash">// xref: init.rc
service adbd /sbin/adbd --root_seclabel=u:r:su:s0 --device_banner=recovery
disabled
socket adbd stream 660 system system 
seclabel u:r:adbd:s0
</code></pre></li>
</ul>

<p><strong>2. adbd启动后，读取<code>ro.adb.secure</code>，决定是否要求PC进行PublicKey+Token认证.</strong></p>

<ul>
<li>为1表示需要认证后，才能建立连接</li>

<li><p>为0表示不需要认证，直接可以建立链接</p>

<pre><code class="language-c">// xref: /system/core/adb/adb.c
int adb_main(int is_daemon, int server_port)
{
// ...
property_get(&quot;ro.adb.secure&quot;, value, &quot;0&quot;);
auth_enabled = !strcmp(value, &quot;1&quot;);
if (auth_enabled)
    adb_auth_init();
// ...
}
</code></pre></li>
</ul>

<p><strong>3. 读取<code>ro.secure</code>，决定是否需要将自身进程降权到SHELL权限(adbd以root权限启动)</strong></p>

<ul>
<li>为1, 降权到SHELL权限</li>

<li><p>为0, 不需要降权</p>

<pre><code class="language-c">// xref: /system/core/adb/adb.c
int adb_main(int is_daemon, int server_port)
{
/* don't listen on a port (default 5037) if running in secure mode */
/* don't run as root if we are running in secure mode */
if (should_drop_privileges()) {    // 内部依据`ro.secure`
    drop_capabilities_bounding_set_if_needed();

    /* then switch user and group to &quot;shell&quot; */
    if (setgid(AID_SHELL) != 0) {
        exit(1);
    }
    if (setuid(AID_SHELL) != 0) {
        exit(1);
    }

    D(&quot;Local port disabled\n&quot;);
} else {
// ...
}
</code></pre></li>
</ul>

<p><strong>4. 开启线程监控 <code>/dev/android_adb</code>或<code>/dev/usb-ffs/adb/ep0</code> , 监控adb的连接：</strong></p>

<pre><code class="language-c">// xref: /system/core/adb/usb_linux_client.c
static void *usb_adb_open_thread(void *x)
{
    struct usb_handle *usb = (struct usb_handle *)x;
    int fd;

    while (1) {
        // wait until the USB device needs opening
        adb_mutex_lock(&amp;usb-&gt;lock);
        while (usb-&gt;fd != -1)
            adb_cond_wait(&amp;usb-&gt;notify, &amp;usb-&gt;lock);
        adb_mutex_unlock(&amp;usb-&gt;lock);

        D(&quot;[ usb_thread - opening device ]\n&quot;);
        do {
            /* XXX use inotify? */
            fd = unix_open(&quot;/dev/android_adb&quot;, O_RDWR);  // 尝试打开，如果成功，认为adb被连接
            if (fd &lt; 0) {
                // to support older kernels
                fd = unix_open(&quot;/dev/android&quot;, O_RDWR);
            }
            if (fd &lt; 0) {
                adb_sleep_ms(1000);
            }
        } while (fd &lt; 0);
        D(&quot;[ opening device succeeded ]\n&quot;);

        close_on_exec(fd);
        usb-&gt;fd = fd;

        D(&quot;[ usb_thread - registering device ]\n&quot;);
        register_usb_transport(usb, 0, 0, 1);
    }

    // never gets here
    return 0;
}
</code></pre>

<p><strong>5. 检查service.adb.tcp.port， 是否需要开启TCP/IP连接模式：</strong></p>

<ul>
<li>不为0, 则开启TCP/IP模式，并且以此值作为监听的端口号.</li>

<li><p>为0, 则不开启.</p>

<pre><code class="language-c">// xref: /system/core/adb/adb.c

int adb_main(int is_daemon, int server_port)
{
// ...

// If one of these properties is set, also listen on that port
// If one of the properties isn't set and we couldn't listen on usb,
// listen on the default port.
property_get(&quot;service.adb.tcp.port&quot;, value, &quot;&quot;);
if (!value[0]) {
    property_get(&quot;persist.adb.tcp.port&quot;, value, &quot;&quot;);
}
if (sscanf(value, &quot;%d&quot;, &amp;port) == 1 &amp;&amp; port &gt; 0) {
    printf(&quot;using port=%d\n&quot;, port);
    // listen on TCP port specified by service.adb.tcp.port property
    local_init(port);  // 开启TCP/IP模式
} else if (!usb) {
    // listen on default port
    local_init(DEFAULT_ADB_LOCAL_TRANSPORT_PORT);
}
// ...
}
</code></pre></li>
</ul>

<p><strong>6、开启socket并开启事件循环，接受Client连接和发来的命令.</strong></p>

<pre><code class="language-c">// xref: /system/core/adb/fdevent.c
void fdevent_loop()
{
    fdevent *fde;
    fdevent_subproc_setup();

    for(;;) {
        D(&quot;--- ---- waiting for events\n&quot;);

        fdevent_process();

        while((fde = fdevent_plist_dequeue())) {
            fdevent_call_fdfunc(fde);
        }
    }
}
</code></pre>

<h2 id="八-总结">八、总结</h2>

<p>总而言之，Adb就是为了方便Host与目标Android设备通讯而出现的一种套件。 USB与TCP/IP只是其通讯的一种方式。另外本文没有阐述的forward与jdwp的通讯本质就是一种TCP代理，所以没有涉及。另外根据本次分析过程里意外得到的灵感中还衍生出几个Adb定制的项目，作为本次分析的#TODO，便于以后的adb封紧及双域分析的分析。</p>

<h2 id="九-faq">九、FAQ</h2>

<h3 id="1-如何使用tcp-ip模式连接adb">1. 如何使用TCP/IP模式连接ADB</h3>

<p>使用TCP/IP模式的方法分为两种：</p>

<p><strong>第一种</strong> 连接adb后在PC上切换</p>

<p>详见上文中<code>二、基本用法</code>中的<code>A. 切换为TCP/IP模式</code></p>

<p><strong>第二种</strong> 使设备天然支持TCP/IP模式</p>

<p>详见上文中<code>三、Android中跟Adb相关的property</code>中的<code>C. adb的连接模式</code></p>

<h3 id="2-如何让adb不验证公钥证书而允许所有pc直接连接">2. 如何让adb不验证公钥证书而允许所有PC直接连接</h3>

<p>详见上问中<code>三、Android中跟Adb相关的property</code>中的<code>adb连接时，是否需要进行需要用户授权验证</code></p>

<h3 id="3-如何让adb只允许指定的-机器-publickey-连接">3. 如何让adb只允许指定的<code>机器/PublicKey</code>连接</h3>

<p>目前没有发现可直接通过property或其他Config配置的方法，但可以通过<code>修改代码</code>+<code>增加配置</code>实现：</p>

<p><strong>1. 禁止询问用户<code>调试授权</code>：</strong></p>

<p>调试授权：adb原生逻辑中，当TOKEN验证失败后，PC会重发PUBLICKEY给Mobile，尝试重新建立授权。
对代码修改，不再允许<code>申请调试授权</code>！</p>

<pre><code class="language-c">// xref: /system/core/adb/adb.c
void handle_packet(apacket *p, atransport *t)
{
    asocket *s;
    // ...
    case A_AUTH:
        if (p-&gt;msg.arg0 == ADB_AUTH_TOKEN) {
            t-&gt;connection_state = CS_UNAUTHORIZED;
            t-&gt;key = adb_auth_nextkey(t-&gt;key);
            if (t-&gt;key) {
                send_auth_response(p-&gt;data, p-&gt;msg.data_length, t);
            } else {
                /* No more private keys to try, send the public key */
                send_auth_publickey(t);
            }
        } else if (p-&gt;msg.arg0 == ADB_AUTH_SIGNATURE) {
            if (adb_auth_verify(t-&gt;token, p-&gt;data, p-&gt;msg.data_length)) {
                adb_auth_verified(t);
                t-&gt;failed_auth_attempts = 0;
            } else {
                if (t-&gt;failed_auth_attempts++ &gt; 10)
                    adb_sleep_ms(1000);
                send_auth_request(t);
            }
        } else if (p-&gt;msg.arg0 == ADB_AUTH_RSAPUBLICKEY) {
            adb_auth_confirm_key(p-&gt;data, p-&gt;msg.data_length, t);  // 此处为收到PC发来的PUBLICKEY，对其计算后向用户询问是否同意授权(弹出：允许USB调试吗？)。所以注释掉此处代码。
        }
        break;
    // ...
    }
    put_apacket(p);
}
</code></pre>

<p><strong>2. 在<code>/data/misc/adb/adb_keys</code>中只保留允许连接的PC的PublicKey</strong></p>

<pre><code>
</code></pre>

<p><strong>3. 最后确保<code>ro.adb.secure</code>为1</strong></p>

<h3 id="4-禁用adb的各种思路">4. 禁用Adb的各种思路</h3>

<p>关于adb的开启/关闭原理可以通过<code>五、adb的开启/关闭</code>了解，从该节可以了解到，adb的开启关闭最终依赖<code>init脚本</code>中的事件功能来实现。
沿着这条流程，可以生出很多种禁掉adb的方式，下面就一一列举几条(只提供思路)：</p>

<ol>
<li>对Settings做定制，在程序启动时直接调用<code>Settings.Global.putInt(getContentResolver(), Settings.Global.ADB_ENABLED, 0);</code>来关闭ADB(最终实现还是通过设置<code>sys.usb.config</code>)</li>
<li>对<code>UsbDeviceManager::addFunction()</code>做修改，当参数<code>functions</code>为“adb”时，就直接返回，不进行下一步操作(不对property做修改)。</li>
<li>修改<code>init.*.usb.rc</code>脚本，将其中包含adb条件的块删除，或做修改，使其不再对property值的变更作出响应。</li>
<li>&hellip;.</li>
</ol>

<h3 id="5-如何让多人访问一台设备">5. 如何让多人访问一台设备</h3>

<p>首先在USB连接了手机的电脑上开启service：</p>

<pre><code class="language-bash">adb nodaemon server -a  # -a 表示监听所有来路
</code></pre>

<p>然后在其他电脑上，指定host来执行命令即可：</p>

<pre><code class="language-bash">adb -H 192.168.128.228 devices
</code></pre>

<h2 id="十-结语">十、结语</h2>

<p>adb作为android系统的原生调试工具极大方便了开发者的调试，其生于android但并不专属于android。
得益于adb的优秀的跨平台能力和与系统低耦合的特性，其被移植到了很多基于unix、linux系统的IoT设备，也被安全定制后放入很多特种设备(不允许外部连接)，但由于系统开发人员对于adb了解不透彻、缺乏安全意识造成了很多的安全风险。在我进行的诸多安全服务项目中，由于adb阉割不完全或保护不当，最终导致各类保密设备、特种设备被攻破的案例屡见不鲜，所以作为一名合格的系统开发人员，完整掌握adb架构和实现绝对是必不可少的。</p>

    
	</div>
  <footer class="article-footer clearfix">
  

<div class="article-tags">
  <span></span>
  
  <a href="https://pkiller.com/tags/android">android</a>
  
  <a href="https://pkiller.com/tags/adb">adb</a>
  
</div>





<div class="article-categories">
  <span></span>
  
  <a class="article-category-link" href="https://pkiller.com/categories/android">android</a>
  
</div>



  <div class="article-share" id="share">
    <div data-url="https://pkiller.com/android/android-adb%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/" data-title="Android Adb 架构及实现分析" data-tsina="" class="share clearfix">
    </div>
  </div>
</footer>

	</article>
  


<section class="comment">
<div id="disqus_thread"></div>
</section>
<script>
  <!-- detect whether Disuqs can load -->
  var xhr = new XMLHttpRequest();
  xhr.open('GET', '//disqus.com/next/config.json?' + new Date().getTime(), true);
  xhr.timeout = 3000; 

  xhr.onload = function() { 


var disqus_config = function () {
this.page.url = "https://pkiller.com/android/android-adb%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/";
this.page.identifier = "https://pkiller.com/android/android-adb%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/";
};
(function() { 
var d = document, s = d.createElement('script');

s.src = '//pkiller.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
}
  xhr.ontimeout = function() {
  <!-- cannot load Disqus, skip it. -->
  return;
}
xhr.send(null);
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


</div>

    <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>
<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">
  
  
  <div class="archiveslist">
    <p class="asidetitle">目录</p>
    <ul class="archive-list">
      <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#一-基本概念">一、基本概念</a>
<ul>
<li><a href="#a-pc端">A. PC端</a></li>
<li><a href="#b-mobile端">B. Mobile端</a></li>
<li><a href="#c-连接模式">C. 连接模式</a></li>
</ul></li>
<li><a href="#二-基本用法">二、基本用法</a>
<ul>
<li><a href="#a-切换为tcp-ip模式">A. 切换为TCP/IP模式</a></li>
</ul></li>
<li><a href="#三-android中相关的property">三、Android中相关的property</a>
<ul>
<li><a href="#a-adbd是否拥有root权限">A. adbd是否拥有ROOT权限</a></li>
<li><a href="#b-adb连接时-是否需要进行需要用户授权验证">B. adb连接时，是否需要进行需要用户授权验证</a></li>
<li><a href="#c-adb的连接模式">C. adb的连接模式</a></li>
<li><a href="#d-adbd-是否运行中">D. Adbd 是否运行中</a></li>
<li><a href="#e-adb是否被打开">E. Adb是否被打开</a></li>
</ul></li>
<li><a href="#四-adb的开启-关闭">四、Adb的开启/关闭</a></li>
<li><a href="#五-adbd-与-server-的授权过程">五、Adbd 与 Server 的授权过程</a></li>
<li><a href="#六-pc端adb-server流程">六、PC端Adb Server流程</a>
<ul>
<li><a href="#a-adb-server-启动流程">A. Adb Server 启动流程</a></li>
</ul></li>
<li><a href="#七-mobile端adbd流程">七、Mobile端Adbd流程</a></li>
<li><a href="#八-总结">八、总结</a></li>
<li><a href="#九-faq">九、FAQ</a>
<ul>
<li><a href="#1-如何使用tcp-ip模式连接adb">1. 如何使用TCP/IP模式连接ADB</a></li>
<li><a href="#2-如何让adb不验证公钥证书而允许所有pc直接连接">2. 如何让adb不验证公钥证书而允许所有PC直接连接</a></li>
<li><a href="#3-如何让adb只允许指定的-机器-publickey-连接">3. 如何让adb只允许指定的<code>机器/PublicKey</code>连接</a></li>
<li><a href="#4-禁用adb的各种思路">4. 禁用Adb的各种思路</a></li>
<li><a href="#5-如何让多人访问一台设备">5. 如何让多人访问一台设备</a></li>
</ul></li>
<li><a href="#十-结语">十、结语</a></li>
</ul></li>
</ul>
</nav>
    </ul>
  </div>
  


  

<div class="categorieslist">
  <p class="asidetitle">分类</p>
  <ul>
    
    <li><a href="https://pkiller.com/categories/about" title="about">about<sup>1</sup></a></li>
    
    <li><a href="https://pkiller.com/categories/android" title="android">android<sup>11</sup></a></li>
    
    <li><a href="https://pkiller.com/categories/midi" title="midi">midi<sup>1</sup></a></li>
    
    <li><a href="https://pkiller.com/categories/%e5%85%b6%e4%bb%96" title="其他">其他<sup>1</sup></a></li>
    
    <li><a href="https://pkiller.com/categories/%e5%ae%89%e5%85%a8" title="安全">安全<sup>1</sup></a></li>
    
    <li><a href="https://pkiller.com/categories/%e6%94%bb%e5%87%bb%e9%9d%a2" title="攻击面">攻击面<sup>1</sup></a></li>
    
    <li><a href="https://pkiller.com/categories/%e6%99%ba%e8%83%bd%e9%9f%b3%e7%ae%b1" title="智能音箱">智能音箱<sup>1</sup></a></li>
    
    <li><a href="https://pkiller.com/categories/%e6%b8%b8%e6%88%8f" title="游戏">游戏<sup>1</sup></a></li>
    
    <li><a href="https://pkiller.com/categories/%e7%97%85%e6%af%92" title="病毒">病毒<sup>1</sup></a></li>
    
    <li><a href="https://pkiller.com/categories/%e9%a3%8e%e6%8e%a7" title="风控">风控<sup>1</sup></a></li>
    
  </ul>
</div>



  

<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
      
			<li><a href="https://pkiller.com/tags/360%e6%91%84%e5%83%8f%e5%a4%b4" title="360摄像头">360摄像头<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/about" title="about">about<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/adb" title="adb">adb<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/addservice" title="addservice">addservice<sup>3</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/android" title="android">android<sup>9</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/android%e9%94%81%e5%b1%8f" title="android锁屏">android锁屏<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/arm" title="arm">arm<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/elf" title="elf">elf<sup>2</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/elf%e6%a0%bc%e5%bc%8f" title="elf格式">elf格式<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/getservice" title="getservice">getservice<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/getsystemservice" title="getsystemservice">getsystemservice<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/kernel" title="kernel">kernel<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/keyguard" title="keyguard">keyguard<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/linker" title="linker">linker<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/midi" title="midi">midi<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/oom" title="oom">oom<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/oom_adj" title="oom_adj">oom_adj<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/publishbinderservice" title="publishbinderservice">publishbinderservice<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/systemservice" title="systemservice">systemservice<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/systemui" title="systemui">systemui<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/unity3d" title="unity3d">unity3d<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/%e5%9b%ba%e4%bb%b6" title="固件">固件<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/%e5%9b%ba%e4%bb%b6%e8%a7%a3%e5%8c%85" title="固件解包">固件解包<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/%e6%91%84%e5%83%8f%e5%a4%b4" title="摄像头">摄像头<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/%e6%99%ba%e8%83%bd%e9%9f%b3%e7%ae%b1" title="智能音箱">智能音箱<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/%e6%b7%b7%e6%b7%86" title="混淆">混淆<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/%e6%b8%b8%e6%88%8f%e8%be%85%e5%8a%a9" title="游戏辅助">游戏辅助<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/%e7%81%b0%e4%ba%a7" title="灰产">灰产<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/%e7%8e%8b%e8%80%85%e8%8d%a3%e8%80%80" title="王者荣耀">王者荣耀<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/%e7%97%85%e6%af%92" title="病毒">病毒<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/%e7%be%8a%e6%af%9b%e5%85%9a" title="羊毛党">羊毛党<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/%e8%84%b1%e5%a3%b3" title="脱壳">脱壳<sup>1</sup></a></li>
      
			<li><a href="https://pkiller.com/tags/%e9%bb%91%e4%ba%a7" title="黑产">黑产<sup>1</sup></a></li>
      
		</ul>
</div>



  
  <div class="archiveslist">
    <p class="asidetitle">归档</p>
    <ul class="archive-list">
      
    </ul>

  </div>


  

<div class="tagcloudlist">
  <p class="asidetitle">标签云</p>
  <div class="tagcloudlist clearfix">
    
    <a href="https://pkiller.com/tags/360%e6%91%84%e5%83%8f%e5%a4%b4" style="font-size: 12px;">360摄像头</a>
    
    <a href="https://pkiller.com/tags/about" style="font-size: 12px;">about</a>
    
    <a href="https://pkiller.com/tags/adb" style="font-size: 12px;">adb</a>
    
    <a href="https://pkiller.com/tags/addservice" style="font-size: 12px;">addservice</a>
    
    <a href="https://pkiller.com/tags/android" style="font-size: 12px;">android</a>
    
    <a href="https://pkiller.com/tags/android%e9%94%81%e5%b1%8f" style="font-size: 12px;">android锁屏</a>
    
    <a href="https://pkiller.com/tags/arm" style="font-size: 12px;">arm</a>
    
    <a href="https://pkiller.com/tags/elf" style="font-size: 12px;">elf</a>
    
    <a href="https://pkiller.com/tags/elf%e6%a0%bc%e5%bc%8f" style="font-size: 12px;">elf格式</a>
    
    <a href="https://pkiller.com/tags/getservice" style="font-size: 12px;">getservice</a>
    
    <a href="https://pkiller.com/tags/getsystemservice" style="font-size: 12px;">getsystemservice</a>
    
    <a href="https://pkiller.com/tags/kernel" style="font-size: 12px;">kernel</a>
    
    <a href="https://pkiller.com/tags/keyguard" style="font-size: 12px;">keyguard</a>
    
    <a href="https://pkiller.com/tags/linker" style="font-size: 12px;">linker</a>
    
    <a href="https://pkiller.com/tags/midi" style="font-size: 12px;">midi</a>
    
    <a href="https://pkiller.com/tags/oom" style="font-size: 12px;">oom</a>
    
    <a href="https://pkiller.com/tags/oom_adj" style="font-size: 12px;">oom_adj</a>
    
    <a href="https://pkiller.com/tags/publishbinderservice" style="font-size: 12px;">publishbinderservice</a>
    
    <a href="https://pkiller.com/tags/systemservice" style="font-size: 12px;">systemservice</a>
    
    <a href="https://pkiller.com/tags/systemui" style="font-size: 12px;">systemui</a>
    
    <a href="https://pkiller.com/tags/unity3d" style="font-size: 12px;">unity3d</a>
    
    <a href="https://pkiller.com/tags/%e5%9b%ba%e4%bb%b6" style="font-size: 12px;">固件</a>
    
    <a href="https://pkiller.com/tags/%e5%9b%ba%e4%bb%b6%e8%a7%a3%e5%8c%85" style="font-size: 12px;">固件解包</a>
    
    <a href="https://pkiller.com/tags/%e6%91%84%e5%83%8f%e5%a4%b4" style="font-size: 12px;">摄像头</a>
    
    <a href="https://pkiller.com/tags/%e6%99%ba%e8%83%bd%e9%9f%b3%e7%ae%b1" style="font-size: 12px;">智能音箱</a>
    
    <a href="https://pkiller.com/tags/%e6%b7%b7%e6%b7%86" style="font-size: 12px;">混淆</a>
    
    <a href="https://pkiller.com/tags/%e6%b8%b8%e6%88%8f%e8%be%85%e5%8a%a9" style="font-size: 12px;">游戏辅助</a>
    
    <a href="https://pkiller.com/tags/%e7%81%b0%e4%ba%a7" style="font-size: 12px;">灰产</a>
    
    <a href="https://pkiller.com/tags/%e7%8e%8b%e8%80%85%e8%8d%a3%e8%80%80" style="font-size: 12px;">王者荣耀</a>
    
    <a href="https://pkiller.com/tags/%e7%97%85%e6%af%92" style="font-size: 12px;">病毒</a>
    
    <a href="https://pkiller.com/tags/%e7%be%8a%e6%af%9b%e5%85%9a" style="font-size: 12px;">羊毛党</a>
    
    <a href="https://pkiller.com/tags/%e8%84%b1%e5%a3%b3" style="font-size: 12px;">脱壳</a>
    
    <a href="https://pkiller.com/tags/%e9%bb%91%e4%ba%a7" style="font-size: 12px;">黑产</a>
    
  </div>
</div>



  

</aside>
</div>

  </div>
  <footer><div id="footer" >
  
  <div class="line">
    <span></span>
    <div style='background:no-repeat url("https://pkiller.com/images/avatar.jpeg") left top;-webkit-background-size:6.875em 6.875em;-moz-background-size:6.875em 6.875em;background-size:6.875em 6.875em;' class="author" ></div>
  </div>
  
  
  <section class="info">
    <p>pkiller </p>
  </section>
  
  <div class="social-font clearfix">
    
    
    
    <a href="https://github.com/pkilller" target="_blank" title="github"></a>
    
    
    
  </div>
  <p class="copyright">Powered by <a href="http://gohugo.io" target="_blank" title="hugo">hugo</a> and Theme by <a href="https://github.com/coderzh/hugo-pacman-theme" target="_blank" title="hugo-pacman-theme">hugo-pacman-theme</a> © 2019
    
    <a href="https://pkiller.com/" title="pkiller">pkiller</a>
    
  </p>
</div>
</footer>
  <script src="https://pkiller.com/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
done = false;
$(document).ready(function(){
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize();
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  $('form.search').on('submit', function (event) {
    if (false === done) {
      event.preventDefault();
      var orgVal = $(this).find('#search').val();
      $(this).find('#search').val('site:https:\/\/pkiller.com\/ ' + orgVal);
      done = true;
      $(this).submit();
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://b.bshare.cn/barCode?site=weixin&url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});
</script>





</body>
</html>
