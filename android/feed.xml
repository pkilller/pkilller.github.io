<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Androids on pkiller</title>
    <link>https://pkiller.com/android/</link>
    <description>Recent content in Androids on pkiller</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 16 Nov 2020 15:07:23 +0800</lastBuildDate><atom:link href="https://pkiller.com/android/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>逆向专版 super-jadx v1.0.0 发布（jadx反编译工具增强版），支持类、方法、字段、变量重命名</title>
      <link>https://pkiller.com/android/super-jadx_v1.0.0/</link>
      <pubDate>Mon, 16 Nov 2020 15:07:23 +0800</pubDate>
      
      <guid>https://pkiller.com/android/super-jadx_v1.0.0/</guid>
      <description>几天前jadx作者放出了最新的1.2.0版本，首度支持了类、方法、字段的重命名特性。但仍有一些不足和缺陷，所以放出本人对jadx增强后的版本</description>
    </item>
    
    <item>
      <title>Android SystemUI &amp; Keyguard原理分析，加个“摇一摇”解锁</title>
      <link>https://pkiller.com/android/android-systemui-keyguard/</link>
      <pubDate>Fri, 23 Aug 2019 14:10:05 +0800</pubDate>
      
      <guid>https://pkiller.com/android/android-systemui-keyguard/</guid>
      <description>基本知识 本文的所有分析都基于Android 7.0. Keyguard 系统中并不存在Keyguard这个应用，Keyguard实际上是com.android.sys</description>
    </item>
    
    <item>
      <title>Android Adb 架构及实现分析</title>
      <link>https://pkiller.com/android/android-adb%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 14 Aug 2018 23:00:48 +0800</pubDate>
      
      <guid>https://pkiller.com/android/android-adb%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/</guid>
      <description>一、基本概念 Adb(Android-Debug-Bridge)是为了方便Host与目标Android设备通讯而出现的一种套件，支持USB与T</description>
    </item>
    
    <item>
      <title>Android Kernel 逆向分析准备</title>
      <link>https://pkiller.com/android/android-kernel-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%87%86%E5%A4%87/</link>
      <pubDate>Sun, 13 May 2018 21:07:36 +0800</pubDate>
      
      <guid>https://pkiller.com/android/android-kernel-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%87%86%E5%A4%87/</guid>
      <description>步骤1、提取内核文件 提取内核有两种方式： 通过固件包提取，通常包含在KERNEL.img或boot.img之中。 通过root权限的手机提取。 A.</description>
    </item>
    
    <item>
      <title>王者荣耀 - 脱壳及Unity3D脚本提取</title>
      <link>https://pkiller.com/android/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80-%E8%84%B1%E5%A3%B3%E5%8F%8Aunity3d%E8%84%9A%E6%9C%AC%E6%8F%90%E5%8F%96/</link>
      <pubDate>Thu, 26 Apr 2018 11:07:43 +0800</pubDate>
      
      <guid>https://pkiller.com/android/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80-%E8%84%B1%E5%A3%B3%E5%8F%8Aunity3d%E8%84%9A%E6%9C%AC%E6%8F%90%E5%8F%96/</guid>
      <description>王者荣耀采用流行的Unity3d框架开发，主要游戏逻辑使用C#编写， 但目前尚未确认是否有使用到Lua。 一、关于Unity3D Unity3D是</description>
    </item>
    
    <item>
      <title>bionic linker 定制 - 无痕加载library</title>
      <link>https://pkiller.com/android/bionic-linker-%E5%AE%9A%E5%88%B6-%E6%97%A0%E7%97%95%E5%8A%A0%E8%BD%BDso%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Wed, 11 Apr 2018 10:06:24 +0800</pubDate>
      
      <guid>https://pkiller.com/android/bionic-linker-%E5%AE%9A%E5%88%B6-%E6%97%A0%E7%97%95%E5%8A%A0%E8%BD%BDso%E6%A8%A1%E5%9D%97/</guid>
      <description>最近研究了一些防内存检测方面的姿势, 异常so模块检测在对抗中占了挺重要的部分. 由于`Bionic/linker`完全是一个用户态的实现, 所以</description>
    </item>
    
    <item>
      <title>ARMv8代码定式</title>
      <link>https://pkiller.com/android/armv8%E4%BB%A3%E7%A0%81%E5%AE%9A%E5%BC%8F/</link>
      <pubDate>Mon, 23 Oct 2017 16:42:28 +0800</pubDate>
      
      <guid>https://pkiller.com/android/armv8%E4%BB%A3%E7%A0%81%E5%AE%9A%E5%BC%8F/</guid>
      <description>本文案例默认编译自android-ndk-r10d, 并且编译选项的均为: APP_OPTIM := release OPT_CFLAGS := -O2&amp;quot; 若为其它ndk环境将会在小节开头处有特殊说明. 一. 成员函</description>
    </item>
    
    <item>
      <title>某android蠕虫木马病毒分析</title>
      <link>https://pkiller.com/android/%E6%9F%90android%E8%A0%95%E8%99%AB%E6%9C%A8%E9%A9%AC%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 04 Jun 2017 22:18:05 +0800</pubDate>
      
      <guid>https://pkiller.com/android/%E6%9F%90android%E8%A0%95%E8%99%AB%E6%9C%A8%E9%A9%AC%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/</guid>
      <description>偶然机会得来一个应用，运行起来后发现桌面图标没了觉得很是可疑，所以花了点时间分析了一下。以下暂用sample样本指代。 经过行为分析，samp</description>
    </item>
    
    <item>
      <title>Android服务注册及获取</title>
      <link>https://pkiller.com/android/android%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%8A%E8%8E%B7%E5%8F%96/</link>
      <pubDate>Sun, 14 May 2017 18:32:05 +0800</pubDate>
      
      <guid>https://pkiller.com/android/android%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%8A%E8%8E%B7%E5%8F%96/</guid>
      <description>本文以Android 5.1为例展开，在7.0上细节会略有差异，但基本一致： Service大致分为两种 1. 系统服务SystemService // 以</description>
    </item>
    
    <item>
      <title>Android进程级别和oom_adj对应关系</title>
      <link>https://pkiller.com/android/android-%E8%BF%9B%E7%A8%8B%E7%BA%A7%E5%88%AB-%E5%92%8C-oom_adj%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Sun, 26 Feb 2017 12:56:34 +0800</pubDate>
      
      <guid>https://pkiller.com/android/android-%E8%BF%9B%E7%A8%8B%E7%BA%A7%E5%88%AB-%E5%92%8C-oom_adj%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/</guid>
      <description>oom_adj 数值越小证明优先级越高, 被干掉的时间越晚. 如果大于 8 一般就是属于 backgroud 随时可能被干掉. -100为system进程的值, 表示绝不会被干掉. [oom_adj=0] 前台</description>
    </item>
    
    <item>
      <title>ELF的DUMP及修复思路</title>
      <link>https://pkiller.com/android/elf%E7%9A%84dump%E5%8F%8A%E4%BF%AE%E5%A4%8D%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Tue, 12 Jul 2016 11:02:04 +0800</pubDate>
      
      <guid>https://pkiller.com/android/elf%E7%9A%84dump%E5%8F%8A%E4%BF%AE%E5%A4%8D%E6%80%9D%E8%B7%AF/</guid>
      <description>加壳后ELF的section基本是被抹掉或是被写垃圾数据的, 但section对于静态分析来讲又非常重要, 所以DUMP后有必要重建sectio</description>
    </item>
    
    <item>
      <title>ELF32 (Android ARM)</title>
      <link>https://pkiller.com/android/elf32-android-arm/</link>
      <pubDate>Sat, 18 Jun 2016 08:36:15 +0800</pubDate>
      
      <guid>https://pkiller.com/android/elf32-android-arm/</guid>
      <description>首先勘误： 下图中 用STB_WEAK 来表示导出函数是错误的。 1. .rel.dyn(DT_REL) 和 .rel.plt(DT_JMPREL) 的区别. 在任意位置 使用静态方式 调用导入函数(API) 引用项会出现在.rel</description>
    </item>
    
    <item>
      <title>Java混淆/反混淆/加固 总结</title>
      <link>https://pkiller.com/android/java%E6%B7%B7%E6%B7%86%E6%8A%80%E5%B7%A7-%E5%8F%8D%E6%B7%B7%E6%B7%86-%E5%8A%A0%E5%9B%BA-%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 18 Jun 2016 08:36:15 +0800</pubDate>
      
      <guid>https://pkiller.com/android/java%E6%B7%B7%E6%B7%86%E6%8A%80%E5%B7%A7-%E5%8F%8D%E6%B7%B7%E6%B7%86-%E5%8A%A0%E5%9B%BA-%E6%80%BB%E7%BB%93/</guid>
      <description>混淆手段 定义超长类名 可以造成超长文件名, 造成常规反编译工具失败(路径太长). 例子: oooooooooooooo 找茬 OoOoOoooOOooo $$_$$$$$ 使用Java关键字 java对关键字检查操作在编译</description>
    </item>
    
  </channel>
</rss>
